<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[lsharemy]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://lsharemy.com//"/>
  <updated>2015-08-26T08:58:29.000Z</updated>
  <id>http://lsharemy.com//</id>
  
  <author>
    <name><![CDATA[lmy]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[自己动手更换翼搏尾灯及灯罩]]></title>
    <link href="http://lsharemy.com/Life/diy-ecosport-tail-light-lens/"/>
    <id>http://lsharemy.com/Life/diy-ecosport-tail-light-lens/</id>
    <published>2015-08-23T03:07:57.000Z</published>
    <updated>2015-08-26T08:58:29.000Z</updated>
    <content type="html"><![CDATA[<p>车的尾灯罩被撞坏了，发现的时候可能都过了几天了，还是一个搭车小伙伴告诉我车灯破了，自己可能还要过好久才发现呢。</p>
<p><img src="http://i.minus.com/ib1sk2RgxjRgCN.jpg" alt=""></p>
<p>如图，灯泡都裸露在外面啦。试了下灯光，发现下面那个透明的灯泡（刹车灯）已经坏了，上面黄色的灯（转向灯）还能用。</p>
<p>网上搜了下，好像4S店要600+，外面的修车店也要400+，然后自己某宝买来自己装的话只要200就够了。</p>
<p>像我这样天（吃）生（饱）爱（了）捣（撑）鼓（着）的人，肯定是选择买一个自己装啦。</p>
<p>选了个杭州的店家，第二天就到货了。<a id="more"></a></p>
<p><img src="http://i.minus.com/ib2wopXyzftd4X.jpg" alt=""></p>
<p>准备动手啦，如图是车灯灯罩和工具和合影</p>
<p><img src="http://i.minus.com/ibucAuM9Af8fm1.jpg" alt=""></p>
<p>灯罩正面也来一张</p>
<p><img src="http://i.minus.com/iOLXKWBEcVU3B.jpg" alt=""></p>
<p>接下来需要先把破的灯罩拆下来，打开后备箱，在左侧有一个暗箱。可以用一字螺丝刀轻轻撬开。</p>
<p><img src="http://i.minus.com/ikWYRoAC6gb0E.jpg" alt=""></p>
<p>撬开后，是这样的</p>
<p><img src="http://i.minus.com/io9KWVo7DPArE.jpg" alt=""></p>
<p>往车灯侧方向看，会看到两颗塑料螺丝，用手拧下来</p>
<p><img src="http://i.minus.com/iKQ2NJDB8SdDC.jpg" alt=""></p>
<p>这就是那两颗塑料螺丝</p>
<p><img src="http://i.minus.com/iDvLtYyiXVKF1.jpg" alt=""></p>
<p>然后就可以从外侧把灯罩给拔出来啦</p>
<p><img src="http://i.minus.com/ibnzL25cI8upsl.jpg" alt=""></p>
<p>将那个插头拔掉，就可以把整个灯罩卸下。左边是旧的，右边是新的，这个时候需要把旧的上面的电路板给换到新的上。</p>
<p><img src="http://i.minus.com/inGjICmIKBP9C.jpg" alt=""></p>
<p>需要注意的就是卸电路板的时候，需要拧3颗螺丝，但是这个螺丝是六角梅花形的，还好我带了螺丝套装。</p>
<p><img src="http://i.minus.com/ibk9Yxf9DuSf9V.jpg" alt=""></p>
<p>拆下来就是这样的</p>
<p><img src="http://i.minus.com/iyxpSb9BEHu07.jpg" alt=""></p>
<p>准备把坏的灯泡换掉的时候，发现店家给我寄的灯泡接口不对，需要的是卡口的（圆形），但是寄过来的是扁扁的头。于是让老妈去旁边修车店买了一个，20大洋。</p>
<p><img src="http://i.minus.com/iAfrOCKxKlpfw.jpg" alt=""></p>
<p>换好灯泡，电路板也就位，可以装回去啦</p>
<p><img src="http://i.minus.com/itcGLELWuA3o3.jpg" alt=""></p>
<p>最后留个念</p>
<p><img src="http://i.minus.com/ibdc86onbEEruR.jpg" alt=""></p>
<p>噔~噔~噔~等~~~</p>
<p><img src="http://i.minus.com/iu5A8cQh06bVc.jpg" alt=""></p>
<p>收工！</p>
<p>第一次，耗时半小时，已经很不错了。下次再换估计5分钟可以搞定。</p>
<p>费用：灯罩168，灯泡20。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>车的尾灯罩被撞坏了，发现的时候可能都过了几天了，还是一个搭车小伙伴告诉我车灯破了，自己可能还要过好久才发现呢。</p>
<p><img src="http://i.minus.com/ib1sk2RgxjRgCN.jpg" alt=""></p>
<p>如图，灯泡都裸露在外面啦。试了下灯光，发现下面那个透明的灯泡（刹车灯）已经坏了，上面黄色的灯（转向灯）还能用。</p>
<p>网上搜了下，好像4S店要600+，外面的修车店也要400+，然后自己某宝买来自己装的话只要200就够了。</p>
<p>像我这样天（吃）生（饱）爱（了）捣（撑）鼓（着）的人，肯定是选择买一个自己装啦。</p>
<p>选了个杭州的店家，第二天就到货了。]]>
    
    </summary>
    
      <category term="DIY" scheme="http://lsharemy.com/tags/DIY/"/>
    
      <category term="Ecosport" scheme="http://lsharemy.com/tags/Ecosport/"/>
    
      <category term="Life" scheme="http://lsharemy.com/categories/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[wordpress迁移到Hexo遇到的问题]]></title>
    <link href="http://lsharemy.com/CS/Migrating-from-Wordpress-to-Hexo/"/>
    <id>http://lsharemy.com/CS/Migrating-from-Wordpress-to-Hexo/</id>
    <published>2015-08-19T08:16:44.000Z</published>
    <updated>2015-08-26T08:58:29.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li><p>wordpress内容导出不完全<br>可能是服务器主机的内存有限？<br>最后在本地搭了个wordpress环境，并导入数据库。然后再本地的wordpress dashboard中进行导出，成功。</p>
</li>
<li><p>运行hexo migrate wordpress (source)出错<br>JS-YAML: can not read a block mapping entry; a multiline key may not be an implicit key at line 2, column 5:<br>date: 2012-09-30 12:58:01<br>^<br>是因为某一篇文章的title中有引号导致的，去除引号之后，搞定</p>
</li>
<li><p>运行hexo generate出错  <a id="more"></a><br>FATAL Something’s wrong. Maybe you can find the solution here: <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">http://hexo.io/docs/troubleshooting.html</a><br>Template render error: expected variable end<br>at Error.exports.TemplateError (d:\lsharemy\node_modules\hexo\node_modules\nunjucks\src\lib.js:51:19)<br>at Object.extend.fail (d:\lsharemy\node_modules\hexo\node_modules\nunjucks\src\parser.js:64:15)<br>at Object.extend.advanceAfterVariableEnd (d:\lsharemy\node_modules\hexo\node_modules\nunjucks\src\parser.js:133:18)<br>at Object.extend.parseNodes (d:\lsharemy\node_modules\hexo\node_modules\nunjucks\src\parser.js:1159:22)<br>at Object.extend.parseAsRoot (d:\lsharemy\node_modules\hexo\node_modules\nunjucks\src\parser.js:1177:42)<br>at Object.module.exports.parse (d:\lsharemy\node_modules\hexo\node_modules\nunjucks\src\parser.js:1199:18)<br>at Object.module.exports.compile (d:\lsharemy\node_modules\hexo\node_modules\nunjucks\src\compiler.js:1118:48)<br>at Obj.extend._compile (d:\lsharemy\node_modules\hexo\node_modules\nunjucks\src\environment.js:444:35)<br>at Obj.extend.compile (d:\lsharemy\node_modules\hexo\node_modules\nunjucks\src\environment.js:433:18)<br>at null.&lt; anonymous&gt; (d:\lsharemy\node_modules\hexo\node_modules\nunjucks\src\environment.js:378:22)<br>at Object.exports.withPrettyErrors (d:\lsharemy\node_modules\hexo\node_modules\nunjucks\src\lib.js:24:16)<br>at Obj.extend.render (d:\lsharemy\node_modules\hexo\node_modules\nunjucks\src\environment.js:374:20)<br>at Obj.extend.renderString (d:\lsharemy\node_modules\hexo\node_modules\nunjucks\src\environment.js:261:21)<br>at d:\lsharemy\node_modules\hexo\lib\extend\tag.js:56:9<br>at tryCatcher (d:\lsharemy\node_modules\hexo\node_modules\bluebird\js\main\util.js:26:23)<br>at Promise._resolveFromResolver (d:\lsharemy\node_modules\hexo\node_modules\bluebird\js\main\promise.js:476:31)<br>at new Promise (d:\lsharemy\node_modules\hexo\node_modules\bluebird\js\main\promise.js:69:37)<br>at Tag.render (d:\lsharemy\node_modules\hexo\lib\extend\tag.js:55:10)<br>at Object.tagFilter [as onRenderEnd] (d:\lsharemy\node_modules\hexo\lib\hexo\post.js:253:16)<br>at Promise.then.then.then.output (d:\lsharemy\node_modules\hexo\lib\hexo\render.js:55:19)<br>at tryCatcher (d:\lsharemy\node_modules\hexo\node_modules\bluebird\js\main\util.js:26:23)<br>at Promise._settlePromiseFromHandler (d:\lsharemy\node_modules\hexo\node_modules\bluebird\js\main\promise.js:503:31)<br>at Promise._settlePromiseAt (d:\lsharemy\node_modules\hexo\node_modules\bluebird\js\main\promise.js:577:18)<br>at Promise._settlePromises (d:\lsharemy\node_modules\hexo\node_modules\bluebird\js\main\promise.js:693:14)<br>at Async._drainQueue (d:\lsharemy\node_modules\hexo\node_modules\bluebird\js\main\async.js:123:16)<br>at Async._drainQueues (d:\lsharemy\node_modules\hexo\node_modules\bluebird\js\main\async.js:133:10)<br>at Async.drainQueues (d:\lsharemy\node_modules\hexo\node_modules\bluebird\js\main\async.js:15:14)<br>at process._tickCallback (node.js:442:13)<br>删除掉部分文章后，就可以生成成功，说明应该是某些文章的解析出了问题<br>usaco-prob-party-lamps.md<br>int d[4][2] = { {1, 1}, {1, 2}, {2, 2}, {1, 3} }; 多维数组定义，背hexo认为是变量，然后出错了。<br>加两个空格搞定。</p>
</li>
<li><p>url不想变<br><a href="http://lsharemy.com/wordpress/index.php/lmy/20121102-20130908/">http://lsharemy.com/wordpress/index.php/lmy/20121102-20130908/</a><br>比如原来一篇文章的链接是这样的<br>后来想到可以将wordpress和index.php认为是一个类别，然后配置permalink: :category/:title来达到目的<br>不过还有个小问题，Hexo中会默认将.替换成-，也就是变成了index-php。<br>后来直接改slugize的源文件，让其不要转义.<br>\node_modules\hexo\node_modules\hexo-util\lib\slugize.js<br>post的链接算是搞定</p>
</li>
<li><p>某些googlg服务被墙导致的速度慢的问题<br>\themes\landscape\source\css_variables.styl<br>24行，font-mono中，删除”Source Code Pro”字体<br>\themes\landscape\layout_partial\head.ejs<br>删除&lt; link href=”//fonts.googleapis.com/css?family=Source+Code+Pro” rel=”stylesheet” type=”text/css”&gt;<br>\themes\landscape\layout_partial\after-footer.ejs<br>将&lt; script src=”//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js”&gt;&lt; /script&gt;<br>替换为<br>&lt; script src=”<a href="http://libs.baidu.com/jquery/2.0.3/jquery.min.js&quot;&gt;" target="_blank" rel="external">http://libs.baidu.com/jquery/2.0.3/jquery.min.js&quot;&gt;</a>&lt; /script&gt;<br>这样之后，访问速度快了很多  </p>
</li>
<li><p>部署到github<br><code>npm install hexo-deployer-git --save</code></p>
</li>
</ol>
<pre><code><span class="attribute">deploy</span>: <span class="string"> </span>
    <span class="attribute">type</span>: <span class="string">git  </span>
    <span class="attribute">repository</span>: <span class="string">https://github.com/lsharemy/lsharemy.github.io.git</span>
    <span class="attribute">branch</span>: <span class="string">master  </span>
</code></pre><p>现在type是git，如果填github，会提示ERROR Deployer not found: github</p>
<ol>
<li><p>cname<br>npm install hexo-generator-cname –save</p>
</li>
<li><p>百度统计<br>将统计代码放在themes/landscape/layout/_partial/header.ejs中<br>&lt; /head &gt;标签前</p>
</li>
<li><p>评论<br>Disqus<br>wordpress直接可以导入<br>有个小问题就是，对于page的评论匹配不了。<br>后来发现是Hexo对于post和page的permalink的格式有点不一样<br>page的permalink的结尾有/index.html，而post没有<br>wordpress导出的xml中，是没有/index.html的<br>本来想改Hexo的代码的，后来怕改出什么问题，于是修改了wordpress导出的xml，在page的链接后面都加上了/index.html</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li><p>wordpress内容导出不完全<br>可能是服务器主机的内存有限？<br>最后在本地搭了个wordpress环境，并导入数据库。然后再本地的wordpress dashboard中进行导出，成功。</p>
</li>
<li><p>运行hexo migrate wordpress (source)出错<br>JS-YAML: can not read a block mapping entry; a multiline key may not be an implicit key at line 2, column 5:<br>date: 2012-09-30 12:58:01<br>^<br>是因为某一篇文章的title中有引号导致的，去除引号之后，搞定</p>
</li>
<li><p>运行hexo generate出错]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://lsharemy.com/tags/Hexo/"/>
    
      <category term="Wordpress" scheme="http://lsharemy.com/tags/Wordpress/"/>
    
      <category term="CS" scheme="http://lsharemy.com/categories/CS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2012年11月02日 – 2013年09月08日 快一年没更新了]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/lmy/20121102-20130908/"/>
    <id>http://lsharemy.com/wordpress/index.php/lmy/20121102-20130908/</id>
    <published>2013-09-08T15:38:45.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>好吧，这一年发生了很多</p>
<p>记下几个重要的日子</p>
<p><a id="more"></a>4.15</p>
<p>8.28</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>好吧，这一年发生了很多</p>
<p>记下几个重要的日子</p>
<p>]]>
    
    </summary>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="lmy" scheme="http://lsharemy.com/categories/wordpress/index.php/lmy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[宏定义（#define）总结]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/macro-definition/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/macro-definition/</id>
    <published>2012-11-06T06:19:45.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>简单的宏替换：</p>
<p>#define forever for(;;) // 无限循环</p>
<p>带参数的宏定义：</p>
<p>#define MAX(a, b) ((A) &gt; (B) ? (A) : (B))</p>
<p>注意要加括号以保证计算次序的正确性</p>
<p>在C表标准库中，很多实用宏的例子，比如stdio.h中的getchar和putchar，还有ctype.h中的函数，islower/isupper/…等等</p>
<p>还有就是条件包含和条件编译</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>简单的宏替换：</p>
<p>#define forever for(;;) // 无限循环</p>
<p>带参数的宏定义：</p>
<p>#define MAX(a, b) ((A) &gt; (B) ? (A) : (B))</p>
<p>注意要加括号以保证计算次序的正]]>
    </summary>
    
      <category term="C" scheme="http://lsharemy.com/tags/C/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[extern修饰的函数]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/extern-function/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/extern-function/</id>
    <published>2012-11-05T07:26:03.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>函数定义默认都是extern的，所以显示的指定extern是可选的</p>
<p>但如果想该函数只能在本文件中使用，那么就需要加static关键字</p>
<p><a href="http://stackoverflow.com/questions/496448/how-to-correctly-use-the-extern-keyword-in-c" target="_blank" rel="external">http://stackoverflow.com/questions/496448/how-to-correctly-use-the-extern-keyword-in-c</a></p>
<p>这样理解，应该是对的吧？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>函数定义默认都是extern的，所以显示的指定extern是可选的</p>
<p>但如果想该函数只能在本文件中使用，那么就需要加static关键字</p>
<p><a href="http://stackoverflow.com/questions/496448/how-t]]>
    </summary>
    
      <category term="C" scheme="http://lsharemy.com/tags/C/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[变量存储位置]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/variable-storage-location/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/variable-storage-location/</id>
    <published>2012-11-05T07:18:26.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>有关变量存储的位置，做个笔记。<a id="more"></a></p>
<p>test1.c:</p>
<p>[c]<br>extern int e1; // UND<br>extern int e2; // UND<br>int gu1; // COM<br>int gu2; // COM<br>int g1 = 1; // .data<br>int g2 = 2; // .data<br>int ef1(); // UND<br>int ef2(); // UND<br>static int sgu1; // .bbs<br>static int sgu2; // .bbs<br>static int sg1 = 1; // .data<br>static int sg2 = 2; // .data</p>
<p>char str1[] = &quot;hello, world!&quot;; // .data (size:14 including ‘&#92;&#48;’)<br>char *str2 = &quot;hello, world!&quot;; // str2: .data | &quot;hello, world!&quot;: .rodata</p>
<p>void f1() // .text<br>{<br>    static int slu1; // .bbs<br>    static int slu2; // .bbs<br>    static int sl1 = 1; // .data<br>    static int sl2 = 2; // .data<br>    g1 = ef1();<br>    e1 = ef1();<br>}</p>
<p>void f2() // .text<br>{<br>    static int slu1; // .bbs<br>    static int slu2; // .bbs<br>    static int sl1 = 1; // .data<br>    static int sl2 = 2; // .data<br>    g1 = ef2();<br>    e1 = ef2();<br>    g2 = ef1();<br>    e2 = ef1();<br>}</p>
<p>int main() // .text<br>{<br>    char str3[] = &quot;hello, world!&quot;; // stack<br>    char *str4 = &quot;hello, world!&quot;; // str4: stack | &quot;hello, world!&quot;: .rodata<br>}<br>[/c]</p>
<p>test2.c:</p>
<p>[c]<br>int e1 = 3; // .data<br>int e2 = 4; // .data</p>
<p>int ef1() // .text<br>{<br>    return 1;<br>}</p>
<p>int ef2() // .text<br>{<br>    return 2;<br>}<br>[/c]</p>
<p>其中test1.o的符号表如下：</p>
<p><pre>Symbol table ‘.symtab’ contains 34 entries:<br>   Num:    Value  Size Type    Bind   Vis      Ndx Name<br>     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND<br>     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS test.c<br>     2: 00000000     0 SECTION LOCAL  DEFAULT    1<br>     3: 00000000     0 SECTION LOCAL  DEFAULT    3<br>     4: 00000000     0 SECTION LOCAL  DEFAULT    5<br>     5: 00000000     4 OBJECT  LOCAL  DEFAULT    5 sgu1<br>     6: 00000004     4 OBJECT  LOCAL  DEFAULT    5 sgu2<br>     7: 00000008     4 OBJECT  LOCAL  DEFAULT    3 sg1<br>     8: 0000000c     4 OBJECT  LOCAL  DEFAULT    3 sg2<br>     9: 00000000     0 SECTION LOCAL  DEFAULT    6<br>    10: 00000024     4 OBJECT  LOCAL  DEFAULT    3 sl2.1272<br>    11: 00000028     4 OBJECT  LOCAL  DEFAULT    3 sl1.1271<br>    12: 00000008     4 OBJECT  LOCAL  DEFAULT    5 slu2.1270<br>    13: 0000000c     4 OBJECT  LOCAL  DEFAULT    5 slu1.1269<br>    14: 0000002c     4 OBJECT  LOCAL  DEFAULT    3 sl2.1264<br>    15: 00000030     4 OBJECT  LOCAL  DEFAULT    3 sl1.1263<br>    16: 00000010     4 OBJECT  LOCAL  DEFAULT    5 slu2.1262<br>    17: 00000014     4 OBJECT  LOCAL  DEFAULT    5 slu1.1261<br>    18: 00000000     0 SECTION LOCAL  DEFAULT    8<br>    19: 00000000     0 SECTION LOCAL  DEFAULT    7<br>    20: 00000004     4 OBJECT  GLOBAL DEFAULT  COM gu1<br>    21: 00000004     4 OBJECT  GLOBAL DEFAULT  COM gu2<br>    22: 00000000     4 OBJECT  GLOBAL DEFAULT    3 g1<br>    23: 00000004     4 OBJECT  GLOBAL DEFAULT    3 g2<br>    24: 00000010    14 OBJECT  GLOBAL DEFAULT    3 str1<br>    25: 00000020     4 OBJECT  GLOBAL DEFAULT    3 str2<br>    26: 00000000    28 FUNC    GLOBAL DEFAULT    1 f1<br>    27: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND ef1<br>    28: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND e1<br>    29: 0000001c    48 FUNC    GLOBAL DEFAULT    1 f2<br>    30: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND ef2<br>    31: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND e2<br>    32: 0000004c    80 FUNC    GLOBAL DEFAULT    1 main<br>    33: 00000000     0 NOTYPE  GLOBAL DEFAULT  UND __stack_chk_fail</pre><br>注意到未初始化的非静态全局变量gu1和gu2的Ndx字段为COM，关于这个，这里有讨论：<a href="http://stackoverflow.com/questions/4137522/what-does-com-means-in-the-ndx-column-of-the-symtab-section" target="_blank" rel="external">http://stackoverflow.com/questions/4137522/what-does-com-means-in-the-ndx-column-of-the-symtab-section</a></p>
<p>UND表示外部变量或函数，需要在链接时确定它们的位置。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有关变量存储的位置，做个笔记。]]>
    
    </summary>
    
      <category term="C" scheme="http://lsharemy.com/tags/C/"/>
    
      <category term="ELF" scheme="http://lsharemy.com/tags/ELF/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[itoa和atoi]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/itoa-and-atoi/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/itoa-and-atoi/</id>
    <published>2012-11-04T08:48:49.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>再贴个自己写的itoa和atoi：</p>
<p>[c]</p>
<p>#include &lt;cstdio&gt;</p>
<p>#include &lt;cstring&gt;</p>
<p>#include &lt;cctype&gt;</p>
<p>void reverse(char s[])<br>{<br>    int n = strlen(s);<br>    for (int i = 0, j = n-1; i &lt; j; i++, j–)<br>    {<br>        char c = s[i];<br>        s[i] = s[j];<br>        s[j] = c;<br>    }<br>}</p>
<p>int atoi(char s[])<br>{<br>    int i, n, sign;<br>    for (i = 0; isspace(s[i]); i++)<br>        ;<br>    sign = (s[i] == ‘-‘)?-1:1;<br>    if (s[i] == ‘-‘ || s[i] == ‘+’)<br>        i++;<br>    for (n = 0;  isdigit(s[i]); i++)<br>        n = 10<em>n + (s[i] - ‘0’);<br>    return n</em>sign;<br>}</p>
<p>void itoa(int n, char s[])<br>{<br>    int i = 0, sign = n;<br>    if (n &lt; 0) n = -n;<br>    do<br>    {<br>        s[i++] = n%10 + ‘0’;<br>        n /= 10;<br>    }while(n);<br>    if (sign &lt; 0) s[i++] = ‘-‘;<br>    s[i] = ‘&#92;&#48;’;<br>    reverse(s);<br>}</p>
<p>int main()<br>{<br>    char s[20];<br>    printf(&quot;%d\n&quot;, atoi(&quot;-525&quot;));<br>    itoa(-525, s);<br>    printf(&quot;%s\n&quot;, s);<br>}<br>[/c]</p>
<p>atoi是stdlib.h中的函数，而itoa不属于标准函数，我的atoi没有考虑溢出问题，如果要考虑，写起来还挺麻烦的，具体可以参考标准库中的实现。</p>
<p>itoa上次面试的时候碰到了，没有想到逆序输出，最后reverse这种方法，这个方法是在K&amp;R的经典C中发现的，看来以前看书不认真啊= =</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>再贴个自己写的itoa和atoi：</p>
<p>[c]</p>
<p>#include &lt;cstdio&gt;</p>
<p>#include &lt;cstring&gt;</p>
<p>#include &lt;cctype&gt;</p>
<p>void re]]>
    </summary>
    
      <category term="C" scheme="http://lsharemy.com/tags/C/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二分搜索]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/binary-search/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/binary-search/</id>
    <published>2012-11-04T08:25:19.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>好吧，来贴个自己写的二分搜索代码（包括普通的二分、返回第一个出现位置的二分、以及返回最后一个出现位置的二分）：</p>
<p>[c]</p>
<p>#include &lt;cstdio&gt;</p>
<p>#include &lt;cstdlib&gt;</p>
<p>int bs_left(int *a, int n, int x)<br>{<br>    int l, h, m;<br>    l = -1;<br>    h = n;<br>    while(l+1 != h)<br>    {<br>        m = l + (h-l)/2;<br>        if (x &lt; a[m])<br>            h = m;<br>        else<br>            l = m;<br>    }<br>    if (l == -1 || a[l] != x) return -1;<br>    return l;<br>}</p>
<p>int bs_right(int *a, int n, int x)<br>{<br>    int l, h, m;<br>    l = -1;<br>    h = n;<br>    while(l+1 != h)<br>    {<br>        m = l + (h-l)/2;<br>        if (x &gt; a[m])<br>            l = m;<br>        else<br>            h = m;<br>    }<br>    if (h == n || a[h] != x) return -1;<br>    return h;<br>}</p>
<p>int bs(int *a, int n, int x)<br>{<br>    int l, h, m;<br>    l = 0;<br>    h = n-1;<br>    while(l &lt;= h)<br>    {<br>        m = l + (h-l)/2;<br>        if (x &lt; a[m])<br>            h = m-1;<br>        else if (x &gt; a[m])<br>            l = m+1;<br>        else<br>            return m;<br>    }<br>    return -1;<br>}</p>
<p>main()<br>{<br>    int n;<br>    int x;<br>    scanf(&quot;%d&quot;, &amp;n);<br>    int <em>a = (int</em>)malloc(sizeof(int)*n);<br>    for (int i = 0; i &lt; n; i++)<br>        scanf(&quot;%d&quot;, &amp;a[i]);<br>    scanf(&quot;%d&quot;, &amp;x);<br>    printf(&quot;any:%d\n&quot;, bs(a, n, x));<br>    printf(&quot;first:%d\n&quot;, bs_right(a, n, x));<br>    printf(&quot;last:%d\n&quot;, bs_left(a, n, x));<br>}<br>[/c]</p>
<p>在《C标准库》里看了stdlib.h中bsearch的实现，和我的bs是类似的，标准库也就“不过如此”了，忽忽</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>好吧，来贴个自己写的二分搜索代码（包括普通的二分、返回第一个出现位置的二分、以及返回最后一个出现位置的二分）：</p>
<p>[c]</p>
<p>#include &lt;cstdio&gt;</p>
<p>#include &lt;cstdlib&gt;</p>
<p>]]>
    </summary>
    
      <category term="Algorithm" scheme="http://lsharemy.com/tags/Algorithm/"/>
    
      <category term="C" scheme="http://lsharemy.com/tags/C/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2012年08月31日 - 2012年11月01日 找工作]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/lmy/20120831-20121101/"/>
    <id>http://lsharemy.com/wordpress/index.php/lmy/20120831-20121101/</id>
    <published>2012-11-02T09:08:45.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>好吧</p>
<p>很失败的找工作经历<a id="more"></a></p>
<p>虽然说今年形势不好</p>
<p>但我一直认为是自己的不努力造成的</p>
<p>1.基础不扎实，本科时读过的好书都已经忘的差不多，而研究生期间基本没读几本好书，忙着实习。又迷恋了一段时间做算法题，虽然说代码能力有很大提升，但是这也花掉了我相当多的时间。</p>
<p>2.没有做好充足的准备。如果在8月开始，就开始准备找工作的事情，或许就不会这样了。7月底回了趟家，8月来了之后一直没有紧张起来。直到9月底，A公司的面试失败才让我意识到紧迫性。或许是我把找工作想的太简单了。</p>
<p>3.没有明确的目标。对于想去的E公司，由于笔试的较早，常见笔试题面试题也看的不多，导致笔试直接被刷。M公司的笔试，做的算法题起到了一定的帮助作用，险进面试，最后也成功挺到了终面，但到今天还没有收到通知，估计又没戏了。</p>
<p>就这样，杭州的三个米缸都离我而去。</p>
<p>我也渐渐失去了找工作的斗志。</p>
<p>现在手上一个快过期的D公司offer，待遇略低，在纠结签不签的问题</p>
<p>不管结果如何，接下来一年，我要找回读好书的习惯，积累沉淀，争取一年后能提高自己的砝码</p>
<hr>
<p>G，我会努力向目标靠近</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>好吧</p>
<p>很失败的找工作经历]]>
    
    </summary>
    
      <category term="Diary" scheme="http://lsharemy.com/tags/Diary/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="lmy" scheme="http://lsharemy.com/categories/wordpress/index.php/lmy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[判断一个整数是否为无符号数(unsigned)]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/isunsigned/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/isunsigned/</id>
    <published>2012-10-22T02:18:00.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>#define ISUNSIGNED(a) (a &gt;=0 &amp;&amp; (a=~a,a &gt;=0 ? (a=~a,1):(a=~a,0)))</p>
<p>具体分析见：<a href="http://www.cnblogs.com/xkfz007/archive/2012/03/27/2420172.html" target="_blank" rel="external">http://www.cnblogs.com/xkfz007/archive/2012/03/27/2420172.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>#define ISUNSIGNED(a) (a &gt;=0 &amp;&amp; (a=~a,a &gt;=0 ? (a=~a,1):(a=~a,0)))</p>
<p>具体分析见：<a href="http://www.cnblogs.com/xkfz007/arch]]>
    </summary>
    
      <category term="C" scheme="http://lsharemy.com/tags/C/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[逗号表达式陷阱]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/comma-separated-expression-trap/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/comma-separated-expression-trap/</id>
    <published>2012-10-22T01:50:29.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>以下程序会输出什么：</p>
<p>[c]</p>
<p>#include &lt;cstdio&gt;</p>
<p>using namespace std;</p>
<p>int main(void)<br>{<br>    int a = 1, b = 1, c;<br>    c = a++, b++, ++b;<br>    int d = (a, b++);<br>    printf(&quot;%d %d %d %d\n&quot;, a, b, c, d);<br>}<br>[/c]</p>
<p>答案是（选中下行查看）：</p>
<p><pre><span style="color: #000000;">2 4 1 3</span></pre><br>逗号表达式的要领：<br>(1) 逗号表达式的运算过程为：从左往右逐个计算表达式。<br>(2) 逗号表达式作为一个整体，它的值为最后一个表达式（也即表达式n）的值。<br>(3) 逗号运算符的优先级别在所有运算符中最低。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下程序会输出什么：</p>
<p>[c]</p>
<p>#include &lt;cstdio&gt;</p>
<p>using namespace std;</p>
<p>int main(void)<br>{<br>    int a = 1, b = 1, c;<b]]>
    </summary>
    
      <category term="C" scheme="http://lsharemy.com/tags/C/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sizeof陷阱]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/sizeof-trap/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/sizeof-trap/</id>
    <published>2012-10-21T13:42:35.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>以下程序会输出什么？</p>
<p>[c]</p>
<p>#include &lt;cstdio&gt;</p>
<p>using namespace std;</p>
<p>int main(void)<br>{<br>    int a = 1;<br>    printf(&quot;%d\n&quot;, sizeof(a++));<br>    printf(&quot;%d\n&quot;, a);<br>}<br>[/c]</p>
<p>如果你第一次看到，可能会认为输出是：</p>
<p><pre>4<br>2</pre><br>不过，程序的真正输出是：</p>
<p><pre>4<br>1</pre><br>为什么？这里有篇文章分析的比较全：</p>
<p><a href="http://dev.yesky.com/143/2563643.shtml" target="_blank" rel="external">http://dev.yesky.com/143/2563643.shtml</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>以下程序会输出什么？</p>
<p>[c]</p>
<p>#include &lt;cstdio&gt;</p>
<p>using namespace std;</p>
<p>int main(void)<br>{<br>    int a = 1;<br>    prin]]>
    </summary>
    
      <category term="C" scheme="http://lsharemy.com/tags/C/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[select/poll/epoll]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/select-poll-epoll/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/select-poll-epoll/</id>
    <published>2012-10-18T05:32:21.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>好吧，面试老问这个，总结下</p>
<p>select函数原型：</p>
<p>[c]<br>int select(int nfds, fd_set <em>readfds, fd_set </em>writefds,<br>                  fd_set <em>exceptfds, struct timeval </em>timeout);<br>[/c]</p>
<p>fd_set结构：</p>
<p>[c]</p>
<p>#undef __FD_SETSIZE</p>
<p>#define __FD_SETSIZE    1024</p>
<p>typedef struct {<br>    unsigned long fds_bits[<strong>FD_SETSIZE / (8 * sizeof(long))];<br>} </strong>kernel_fd_set;<br>[/c]</p>
<p>原来就是8个无符号整型的数组，当做位向量来用。</p>
<p>然后相关的FD_CLR、FD_SET、FD_ISSET和FD_ZERO等函数就是相应的位操作了。<a id="more"></a></p>
<p>select中的第一个参数nfds要比你想检查的最大的描述符的值大，因为它会检查0到nfds-1之间的描述符，看其是否可用。</p>
<p>函数返回时，会返回可用描述符的个数，参数中的三个描述符集合向量也会被修改，所以循环调用select的时候，记得重新设置集合向量</p>
<p>由于__FD_SETSIZE被设置为1024，所以select也就最多能检查1024个描述符</p>
<p>poll函数原型：</p>
<p>[c]<br>int poll(struct pollfd *fds, nfds_t nfds, int timeout);<br>[/c]</p>
<p>采用了数组的形式，所以对描述符的个数没有了1024的限制，不过效率还是很慢，因为它还是会遍历所有关心的描述符，看其是否可用（不过比select好点）</p>
<p>结构体：</p>
<p>[c]<br>struct pollfd {<br>    int fd;<br>    short events;<br>    short revents;<br>};<br>[/c]</p>
<p>events表示对该描述符关心的事件，函数返回的时候，可用的描述符的revents会被设置。</p>
<p>epoll相关函数：</p>
<p>[c]<br>int epoll_create(int size);<br>int epoll_ctl(int epfd, int op, int fd, struct epoll_event <em>event);<br>int epoll_wait(int epfd, struct epoll_event </em>events,<br>                      int maxevents, int timeout);<br>[/c]</p>
<p>结构体：</p>
<p>[c]<br>typedef union epoll_data {<br>    void    *ptr;<br>    int      fd;<br>    uint32_t u32;<br>    uint64_t u64;<br>} epoll_data_t;</p>
<p>struct epoll_event {<br>    uint32_t     events;    /<em> Epoll events </em>/<br>    epoll_data_t data;      /<em> User data variable </em>/<br>};<br>[/c]</p>
<p>epoll_create用来创建一个epoll实例</p>
<p>epoll_ctl则用来往增加、删除、修改集合。</p>
<p>epoll_wait等待epoll实例epfd上的事件，函数返回时，返回可用描述符的个数，并将它们放在events指向的地方</p>
<p>epoll与select/poll不一样，不是采用的轮询的方式，而是采用回调函数的方式。因此效率高很多。</p>
<p>参考：<a href="http://blog.dccmx.com/2011/04/select-poll-epoll-in-kernel/" target="_blank" rel="external">http://blog.dccmx.com/2011/04/select-poll-epoll-in-kernel/</a>，</p>
<p><a href="http://www.kegel.com/c10k.html" target="_blank" rel="external">http://www.kegel.com/c10k.html</a>，</p>
<p><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/select_tut.2.html" target="_blank" rel="external">http://www.kernel.org/doc/man-pages/online/pages/man2/select_tut.2.html</a>，</p>
<p><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/select.2.html" target="_blank" rel="external">http://www.kernel.org/doc/man-pages/online/pages/man2/select.2.html</a>，</p>
<p><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/poll.2.html" target="_blank" rel="external">http://www.kernel.org/doc/man-pages/online/pages/man2/poll.2.html</a>，</p>
<p><a href="http://www.kernel.org/doc/man-pages/online/pages/man7/epoll.7.html" target="_blank" rel="external">http://www.kernel.org/doc/man-pages/online/pages/man7/epoll.7.html</a>，</p>
<p><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_create.2.html" target="_blank" rel="external">http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_create.2.html</a>，</p>
<p><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_ctl.2.html" target="_blank" rel="external">http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_ctl.2.html</a>，</p>
<p><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_wait.2.html" target="_blank" rel="external">http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_wait.2.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>好吧，面试老问这个，总结下</p>
<p>select函数原型：</p>
<p>[c]<br>int select(int nfds, fd_set <em>readfds, fd_set </em>writefds,<br>                  fd_set <em>exceptfds, struct timeval </em>timeout);<br>[/c]</p>
<p>fd_set结构：</p>
<p>[c]</p>
<p>#undef __FD_SETSIZE</p>
<p>#define __FD_SETSIZE    1024</p>
<p>typedef struct {<br>    unsigned long fds_bits[<strong>FD_SETSIZE / (8 * sizeof(long))];<br>} </strong>kernel_fd_set;<br>[/c]</p>
<p>原来就是8个无符号整型的数组，当做位向量来用。</p>
<p>然后相关的FD_CLR、FD_SET、FD_ISSET和FD_ZERO等函数就是相应的位操作了。]]>
    
    </summary>
    
      <category term="Linux" scheme="http://lsharemy.com/tags/Linux/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux在线帮助（man）的“章节”]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/section-numbers-of-the-manual/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/section-numbers-of-the-manual/</id>
    <published>2012-10-17T13:35:40.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p><pre>       1   Executable programs or shell commands<br>       2   System calls (functions provided by the kernel)<br>       3   Library calls (functions within program libraries)<br>       4   Special files (usually found in /dev)<br>       5   File formats and conventions eg /etc/passwd<br>       6   Games<br>       7   Miscellaneous  (including  macro  packages and conven‐<br>           tions), e.g. man(7), groff(7)<br>       8   System administration commands (usually only for root)<br>       9   Kernel routines [Non standard]</pre><br>通过man 1 intro可以查看1中的介绍，其他章节类似</p>
<p>使用方法：</p>
<p>查命令：man 1 ls</p>
<p>查系统调用：man 2 open</p>
<p>查库函数：man 3 printf</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><pre>       1   Executable programs or shell commands<br>       2   System calls (functions provided by the kernel)<br>       3   Library]]>
    </summary>
    
      <category term="Linux" scheme="http://lsharemy.com/tags/Linux/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vector的简单实现]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/a-simple-implementation-of-vector/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/a-simple-implementation-of-vector/</id>
    <published>2012-10-11T09:22:19.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>实现一个vector，学习到了C++中的不少概念。</p>
<p>1.用explicit来防止隐式转换的发生<br>2.用形参的默认值来减少构造函数的个数<br>3.复制构造函数和赋值操作符的定义<br>4.vector的内存分配机制</p>
<p>[c]<br>template &lt;class T&gt;<br>class Vector<br>{<br>public:<br>    explicit Vector (int initSize = 0)<br>    : theSize(initSize), theCapacity(initSize)<br>    {<br>        objects = new T[theCapacity];<br>    }<br>    Vector(const Vector &amp; rhs):objects(NULL)<br>    {<br>        operator=(rhs);<br>    }<br>    const Vector &amp; operator=(const Vector &amp; rhs)<br>    {<br>        if (this != &amp;rhs)<br>        {<br>            delete [] objects;<br>            theSize = rhs.size();<br>            theCapacity = rhs.theCapacity;</p>
<pre><code>        objects = <span class="keyword">new</span> T[capacity()];
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; size(); i++)
            objects[i] = rhs.objects[i];
    }
    <span class="keyword">return</span> *<span class="keyword">this</span>;
}
~Vector()
{
    <span class="keyword">delete</span> [] objects;
}

<span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newSize)</span>
</span>{
    <span class="keyword">if</span> (newSize &amp;gt; theCapacity)
        reserve(newSize);
    theSize = newSize;
}

<span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">( <span class="keyword">int</span> newCapacity)</span>
</span>{
    T *oldArray = objects;
    objects = <span class="keyword">new</span> T[newCapacity];
    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; theSize; i++)
        objects[i] = oldArray[i];
    theCapacity = newCapacity;
    <span class="keyword">delete</span> [] oldArray;
}

<span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span>
</span>{
    <span class="keyword">return</span> theSize;
}

<span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span>
</span>{
    <span class="keyword">return</span> theCapacity;
}

<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp;amp; x)</span>
</span>{
    <span class="keyword">if</span> (theSize == <span class="number">0</span> &amp;amp;&amp;amp; theCapacity == <span class="number">0</span>)
        reserve(<span class="number">1</span>);
    <span class="keyword">else</span> <span class="keyword">if</span> (theSize == theCapacity)
        reserve(<span class="number">2</span>*theCapacity);
    objects[theSize++] = x;
}

<span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span>
</span>{
    theSize--;
}
</code></pre><p>private:<br>    int theSize;<br>    int theCapacity;<br>    T *objects;<br>};<br>[/c]</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>实现一个vector，学习到了C++中的不少概念。</p>
<p>1.用explicit来防止隐式转换的发生<br>2.用形参的默认值来减少构造函数的个数<br>3.复制构造函数和赋值操作符的定义<br>4.vector的内存分配机制</p>
<p>[c]<br>templ]]>
    </summary>
    
      <category term="C" scheme="http://lsharemy.com/tags/C/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vector笔记]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/vector-notes/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/vector-notes/</id>
    <published>2012-10-06T14:15:18.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>[c]</p>
<p>#include &lt;cstdio&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>using namespace std;</p>
<p>int main()<br>{<br>    vector &lt;int&gt; a;<br>    printf(&quot;size:%d capacity:%d\n&quot;, a.size(), a.capacity());<br>    a.push_back(1);<br>    printf(&quot;size:%d capacity:%d\n&quot;, a.size(), a.capacity());<br>    a.push_back(1);<br>    printf(&quot;size:%d capacity:%d\n&quot;, a.size(), a.capacity());<br>    a.push_back(1);<br>    printf(&quot;size:%d capacity:%d\n&quot;, a.size(), a.capacity());<br>    a.push_back(1);<br>    printf(&quot;size:%d capacity:%d\n&quot;, a.size(), a.capacity());<br>    a.push_back(1);<br>    printf(&quot;size:%d capacity:%d\n&quot;, a.size(), a.capacity());<br>    a.push_back(1);<br>    printf(&quot;size:%d capacity:%d\n&quot;, a.size(), a.capacity());<br>    a.push_back(1);<br>    printf(&quot;size:%d capacity:%d\n&quot;, a.size(), a.capacity());<br>    a.push_back(1);<br>    printf(&quot;size:%d capacity:%d\n&quot;, a.size(), a.capacity());<br>    a.clear();<br>    printf(&quot;size:%d capacity:%d\n&quot;, a.size(), a.capacity());<br>}<br>[/c]</p>
<p>输出：</p>
<p><pre>size:0 capacity:0<br>size:1 capacity:1<br>size:2 capacity:2<br>size:3 capacity:4<br>size:4 capacity:4<br>size:5 capacity:8<br>size:6 capacity:8<br>size:7 capacity:8<br>size:8 capacity:8<br>size:0 capacity:8</pre><br>验证2个事实：</p>
<p>1.vector每次容量不够的时候，会申请一个双倍的内存空间，然后被旧的数据拷的新的地方，并释放旧内存。</p>
<p>2.vector在clear之后（或erase很多元素之后），并不会释放内存。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>[c]</p>
<p>#include &lt;cstdio&gt;</p>
<p>#include &lt;vector&gt;</p>
<p>using namespace std;</p>
<p>int main()<br>{<br>    vector &lt;in]]>
    </summary>
    
      <category term="C" scheme="http://lsharemy.com/tags/C/"/>
    
      <category term="Notes" scheme="http://lsharemy.com/tags/Notes/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[字符串匹配算法总结]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/string-matching-algorithms/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/string-matching-algorithms/</id>
    <published>2012-10-03T06:48:50.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>字符串匹配问题就是要在一段文本T中，找出所有模式P出现的所有位置。</p>
<p>假设T的长度为n，P的长度为m，m &lt;= n</p>
<h1 id="蛮力法"><span style="color: #ff0000;">蛮力法</span></h1><p>对于每一个位置s（0 &lt;= s &lt;= n-m），从左到右比较P[1…m]和T[s+1…s+m]是否相同，如果相同，s就是一个有效位移。最坏情况，时间复杂度为O((n-m+1)m)。</p>
<h1 id="Rabin-Karp算法(1987)<!-more->"><span style="color: #ff0000;">Rabin-Karp算法(1987)<a id="more"></a></span></h1><p>将所有字符都赋予d进制数字（d为字符集的大小），然后模式P[1…m]就可以转换成一个d进制数p，转换的的复杂度为O(m)，令ts表示T[1…n]中长度为m的子字符串T[s+1…s+m]对应的d进制数，那么s是有效位移当且仅当ts=p。其中所有ts的计算可以在O(n-m+1)时间内完成，所以总的时间复杂度为O(m)+O(n-m+1)=O(n)，当然这是在理想情况下，即ts和p都不是很大，如果过大，每次算术运算的就不能在常数时间完成。于是采用一个补救措施，计算ts和p对一个合适的数q的模。但这会导致一些伪命中点，所以对于所有满足ts=p (mod q)的点，需从左到右比较P[1…m]和T[s+1…s+m]是否相同。不过由于排除了很多非法位移，相比蛮力法，运行效率会好很多。预处理时间O(m)，匹配时间在最坏情况下为O((n-m+1)m)，不过期望的匹配时间为O(n)。</p>
<h1 id="KMP算法(1977)"><span style="color: #ff0000;">KMP算法(1977)</span></h1><p>通过预计算一个前缀函数π，从而在比较过程中可以跳过很多无效位移。π[q]表示P的最长前缀同时又是P[1…q]的真后缀的长度。预处理时间O(m)，匹配时间O(n)。空间复杂度O(m)。</p>
<p>想看更详细的KMP讲解，可以看<a href="http://book.douban.com/subject/1885170/" target="_blank" rel="external">《算法导论》</a>或到<a href="http://www.matrix67.com/blog/archives/115" target="_blank" rel="external">Matrix67</a>那里去看看。</p>
<h1 id="BM算法(1977)"><span class="Apple-style-span" style="color: #ff0000;">BM算法(1977)</span></h1><p><a href="http://www.cnblogs.com/dsky/archive/2012/05/04/2483190.html" target="_blank" rel="external">这篇博文</a>对BM算法讲的很详细</p>
<p><a href="http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/bmen.htm" target="_blank" rel="external">这还有论文</a></p>
<p><a href="http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm" target="_blank" rel="external">BM算法wiki</a></p>
<h1 id="Sunday算法(1990)"><span style="color: #ff0000;">Sunday算法(1990)</span></h1><p>Horspool(1980)是BM的简化，改进了BM中的坏字符规则，丢弃了好后缀规则，而Sunday又是Horspool的改进</p>
<p><a href="http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/sundayen.htm" target="_blank" rel="external">http://www.inf.fh-flensburg.de/lang/algorithmen/pattern/sundayen.htm</a></p>
<h1 id="two-way算法(1991)"><span style="color: #ff0000;">two-way算法(1991)</span></h1><p>strstr函数的实现使用的是two-way算法。</p>
<hr>
<p>以上所有算法的分析、源码、实例动画等都可以在<a href="http://www-igm.univ-mlv.fr/~lecroq/string/" target="_blank" rel="external">http://www-igm.univ-mlv.fr/~lecroq/string/</a>这里找到，里面还包含了其他更多字符串匹配算法。</p>
<hr>
<h1 id="AC自动机算法(1991)"><span style="color: #ff0000;">AC自动机算法(1991)</span></h1><p>前面几个算法都是用来处理单字符串匹配的，AC自动机是用来处理多字符串匹配的，也就是说模式串有多个。具体可以到<a href="http://hi.baidu.com/nialv7/item/ce1ce015d44a6ba7feded52d" target="_blank" rel="external">这里</a>看看。大概思想是trie树+失败指针。终于知道什么是<a href="http://zh.wikipedia.org/zh/Trie" target="_blank" rel="external">trie树</a>了，输入提示以及词频统计什么的，都是trie树的功劳了。</p>
<p><a href="http://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_string_matching_algorithm" target="_blank" rel="external">http://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_string_matching_algorithm</a></p>
<p>还有UNIX中的fgrep就是用的这个算法。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>字符串匹配问题就是要在一段文本T中，找出所有模式P出现的所有位置。</p>
<p>假设T的长度为n，P的长度为m，m &lt;= n</p>
<h1 id="蛮力法"><span style="color: #ff0000;">蛮力法</span></h1><p>对于每一个位置s（0 &lt;= s &lt;= n-m），从左到右比较P[1…m]和T[s+1…s+m]是否相同，如果相同，s就是一个有效位移。最坏情况，时间复杂度为O((n-m+1)m)。</p>
<h1 id="Rabin-Karp算法(1987)<!-more->"><span style="color: #ff0000;">Rabin-Karp算法(1987)]]>
    
    </summary>
    
      <category term="Algorithm" scheme="http://lsharemy.com/tags/Algorithm/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hello, world!程序编译链接运行深入剖析]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/hello-world-compile-link-run-deepin/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/hello-world-compile-link-run-deepin/</id>
    <published>2012-09-30T12:58:01.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>学C语言的第一个程序就是以下这个helloworld程序:</p>
<p>[c]</p>
<p>#include</p>
<p>int main()<br>{<br>    printf(&quot;hello, world!\n&quot;);<br>}<br>[/c]</p>
<p>它通过gcc -o hello hello.c编译，然后通过./hello就可以运行了，屏幕上打印出”hello, world\n”</p>
<p>不过它是如何被编译和链接的，又是如何在系统中运行的？第二次看《深入理解计算机系统》，终于明白了一点，所以做个总结。</p>
<h1 id="编译"><span style="color: #ff0000;">编译</span></h1><p>gcc -o hello hello.c这个命令其实gcc帮你干完了编译和链接两个工作。（编译其实还包括了汇编，可以把<em>.c-&gt;</em>.s理解为编译，.s-&gt;.o理解为汇编）</p>
<p>如果想只编译那么要用-c选项，gcc -c hello.c，这会生成一个hello.o文件，这是一个可重定位目标文件，有关可重定位目标文件，我在<a href="http://lsharemy.com/wordpress/index.php/csit/elf-file-format/">这篇文章</a>里做过总结。</p>
<p>这个文件由一个ELF头、一个节头部表、以及很多个节组成。<a id="more"></a></p>
<p>比较重要的节有：</p>
<p>.text节，程序编译后的机器代码<br>.rodata节，只读数据，比如字符串常量、switch语句中的跳转表等就放在这个节<br>.data节，已初始化的全局变量<br>.bss节，未初始化的全局变更<br>.symtab节，一个符号表，存放程序中定义和引用的函数和全局变量的信息<br>.rel.text节和.rel.data节存放与重定位有关的信息<br>.debug节和.line节，只有用-g选项进行编译才会有<br>，存放与调试有关的信息<br>.strtab，一个字符串表。</p>
<p>先通过objdump -d -r hello.o对该文件进行反汇编：</p>
<p><pre>00000000 &lt;main&gt;:<br>   0:    55                       push   %ebp<br>   1:    89 e5                    mov    %esp,%ebp<br>   3:    83 e4 f0                 and    $0xfffffff0,%esp<br>   6:    83 ec 10                 sub    $0x10,%esp<br>   9:    c7 04 24 00 00 00 00     movl   $0x0,(%esp)<br>            c: R_386_32    .rodata<br>  10:    e8 fc ff ff ff           call   11 &lt;main+0x11&gt;<br>            11: R_386_PC32    puts<br>  15:    c9                       leave<br>  16:    c3                       ret</pre><br>-r选项同时显示出了代码重需要重定位的地方。这段程序其实就是将参数（字符常指针）入栈之后，调用打印函数。不过由于现在还不确定程序将来会在哪段地址运行，所以还没法确定字符串的地址、以及打印函数的地址，而这要到链接才能确定，到后面再讨论。</p>
<h1 id="链接"><span style="color: #ff0000;">链接</span></h1><p>使用gcc -o hello hello.o来对其进行链接。</p>
<p>链接包括符号解析和重定位两步。</p>
<p>符号解析就是将输入的可重定位目标文件的符号表中的符号与其定义联系起来。比如我们在程序中调用了printf函数，它在系统的一个动态库中定义。</p>
<p>完成符号解析之后，链接器就知道输入目标模块中的代码节和数据节的确切大小了。就可以开始重定位了，这个步骤中，将合并输入模块，并为每一个符号分配运行地址。</p>
<p>重定位分两步组成：</p>
<p>1.重定位节和符号定义。这一步中，连接器将所有相同类型的节合并起来，并为它们赋予存储器地址。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。<br>2.重定位节中的符号引用。这一步，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的地址。</p>
<p>通过链接，就会生成可执行目标文件hello</p>
<p>再看以下hello反汇编的main部分代码：</p>
<p><pre>080483e4 &lt;main&gt;:<br> 80483e4:    55                       push   %ebp<br> 80483e5:    89 e5                    mov    %esp,%ebp<br> 80483e7:    83 e4 f0                 and    $0xfffffff0,%esp<br> 80483ea:    83 ec 10                 sub    $0x10,%esp<br> 80483ed:    c7 04 24 c0 84 04 08     movl   $0x80484c0,(%esp)<br> 80483f4:    e8 1f ff ff ff           call   8048318 &lt;puts@plt&gt;<br> 80483f9:    c9                       leave<br> 80483fa:    c3                       ret<br> 80483fb:    90                       nop<br> 80483fc:    90                       nop<br> 80483fd:    90                       nop<br> 80483fe:    90                       nop<br> 80483ff:    90                       nop</pre><br>看到之前需要重定位的两个地方现在都有了确切的地址了。</p>
<h1 id="运行"><span style="color: #ff0000;">运行</span></h1><p>然后就可以通过./hello运行啦</p>
<p>在Linux中，每个程序都有一个运行时存储器映像，如下图所示（图中“从可执行文件中加载那个大括号括错了，应该往下平移下）：</p>
<p><img src="http://i.minus.com/ib0c7AaN9N4Tpl.JPG" alt="" title="Linux">用readelf -l hello可以看到只读段和读写段分别占用哪段地址：</p>
<p><pre>Program Headers:<br>  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align<br>LOAD           0x000000 0x08048000 0x08048000 0x004d4 0x004d4 R E 0x1000<br>LOAD           0x000f0c 0x08049f0c 0x08049f0c 0x00108 0x00110 RW  0x1000</pre><br>用readelf -S hello可以看到所有节的的信息：</p>
<p><pre>Section Headers:<br>  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al<br>  [ 0]                   NULL            00000000 000000 000000 00      0   0  0<br>  [ 1] .interp           PROGBITS        08048134 000134 000013 00   A  0   0  1<br>  [ 2] .note.ABI-tag     NOTE            08048148 000148 000020 00   A  0   0  4<br>  [ 3] .note.gnu.build-i NOTE            08048168 000168 000024 00   A  0   0  4<br>  [ 4] .hash             HASH            0804818c 00018c 000028 04   A  6   0  4<br>  [ 5] .gnu.hash         GNU_HASH        080481b4 0001b4 000020 04   A  6   0  4<br>  [ 6] .dynsym           DYNSYM          080481d4 0001d4 000050 10   A  7   1  4<br>  [ 7] .dynstr           STRTAB          08048224 000224 00004a 00   A  0   0  1<br>  [ 8] .gnu.version      VERSYM          0804826e 00026e 00000a 02   A  6   0  2<br>  [ 9] .gnu.version_r    VERNEED         08048278 000278 000020 00   A  7   1  4<br>  [10] .rel.dyn          REL             08048298 000298 000008 08   A  6   0  4<br>  [11] .rel.plt          REL             080482a0 0002a0 000018 08   A  6  13  4<br>  [12] .init             PROGBITS        080482b8 0002b8 000030 00  AX  0   0  4<br>  [13] .plt              PROGBITS        080482e8 0002e8 000040 04  AX  0   0  4<br>  [14] .text             PROGBITS        08048330 000330 00016c 00  AX  0   0 16<br>  [15] .fini             PROGBITS        0804849c 00049c 00001c 00  AX  0   0  4<br>  [16] .rodata           PROGBITS        080484b8 0004b8 000016 00   A  0   0  4<br>  [17] .eh_frame         PROGBITS        080484d0 0004d0 000004 00   A  0   0  4<br>  [18] .ctors            PROGBITS        08049f0c 000f0c 000008 00  WA  0   0  4<br>  [19] .dtors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4<br>  [20] .jcr              PROGBITS        08049f1c 000f1c 000004 00  WA  0   0  4<br>  [21] .dynamic          DYNAMIC         08049f20 000f20 0000d0 08  WA  7   0  4<br>  [22] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4<br>  [23] .got.plt          PROGBITS        08049ff4 000ff4 000018 04  WA  0   0  4<br>  [24] .data             PROGBITS        0804a00c 00100c 000008 00  WA  0   0  4<br>  [25] .bss              NOBITS          0804a014 001014 000008 00  WA  0   0  4<br>  [26] .comment          PROGBITS        00000000 001014 000048 01  MS  0   0  1<br>  [27] .shstrtab         STRTAB          00000000 00105c 0000ee 00      0   0  1<br>  [28] .symtab           SYMTAB          00000000 0015fc 000410 10     29  45  4<br>  [29] .strtab           STRTAB          00000000 001a0c 0001fb 00      0   0  1</pre><br>在shell中敲入./hello后，shell会先调用fork()函数创建一个新的哦进程，然后调用exec()函数来加载hello程序，加载器会删除子进程现有的虚拟存储器段，并创建一组新的代码、数据、堆和栈段。其中堆和栈被初始化为零，代码段和数据段被初始化为hello中的相应内容。最后加载器跳转到_start，而它最终会调用hello中的main函数。</p>
<p>（注：加载器并不会把代码段和数据段直接拷贝到内存中，而是在页表中将相应条目指向文件的适当位置，在每个页被引用时，会引发缺页中断，然后虚拟存储器系统会按照需要自动的跳入相应页）</p>
<hr>
<p>以下面这段代码为例，看下C语言中各变量的存储位置：</p>
<p>[c]</p>
<p>#include &lt;stdio.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>int g_not_init1;<br>int g_not_init2;<br>int g_init1 = 1;<br>int g_init2 = 2;</p>
<p>int main()<br>{<br>    char <em>str = &quot;abc&quot;;<br>    int local1 = 1;<br>    int local2 = 2;<br>    static int static1 = 1;<br>    static int static2 = 2;<br>    int </em>p = (int*)malloc(sizeof(int));<br>    printf(&quot;main:%p\n&quot;, main);<br>    printf(&quot;g_not_init1:%p\n&quot;, &amp;g_not_init1);<br>    printf(&quot;g_not_init2:%p\n&quot;, &amp;g_not_init2);<br>    printf(&quot;g_init1:%p\n&quot;, &amp;g_init1);<br>    printf(&quot;g_init2:%p\n&quot;, &amp;g_init2);<br>    printf(&quot;local1:%p\n&quot;, &amp;local1);<br>    printf(&quot;local2:%p\n&quot;, &amp;local2);<br>    printf(&quot;static1:%p\n&quot;, &amp;static1);<br>    printf(&quot;static2:%p\n&quot;, &amp;static2);<br>    printf(&quot;p:%p\n&quot;, p);<br>    printf(&quot;str:%p\n&quot;, str);<br>}<br>[/c]</p>
<p>运行结果：</p>
<p><pre>main:0x8048414<br>g_not_init1:0x804a034<br>g_not_init2:0x804a030<br>g_init1:0x804a018<br>g_init2:0x804a01c<br>local1:0xbfeb3a78<br>local2:0xbfeb3a74<br>static1:0x804a020<br>static2:0x804a024<br>p:0x8191008<br>str:0x80485f0</pre><br>用readelf -S hello查看下节信息：</p>
<p><pre>Section Headers:<br>  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al<br>  [ 0]                   NULL            00000000 000000 000000 00      0   0  0<br>  [ 1] .interp           PROGBITS        08048134 000134 000013 00   A  0   0  1<br>  [ 2] .note.ABI-tag     NOTE            08048148 000148 000020 00   A  0   0  4<br>  [ 3] .note.gnu.build-i NOTE            08048168 000168 000024 00   A  0   0  4<br>  [ 4] .hash             HASH            0804818c 00018c 00002c 04   A  6   0  4<br>  [ 5] .gnu.hash         GNU_HASH        080481b8 0001b8 000020 04   A  6   0  4<br>  [ 6] .dynsym           DYNSYM          080481d8 0001d8 000060 10   A  7   1  4<br>  [ 7] .dynstr           STRTAB          08048238 000238 000053 00   A  0   0  1<br>  [ 8] .gnu.version      VERSYM          0804828c 00028c 00000c 02   A  6   0  2<br>  [ 9] .gnu.version_r    VERNEED         08048298 000298 000020 00   A  7   1  4<br>  [10] .rel.dyn          REL             080482b8 0002b8 000008 08   A  6   0  4<br>  [11] .rel.plt          REL             080482c0 0002c0 000020 08   A  6  13  4<br>  [12] .init             PROGBITS        080482e0 0002e0 000030 00  AX  0   0  4<br>  [13] .plt              PROGBITS        08048310 000310 000050 04  AX  0   0  4<br>  [14] .text             PROGBITS        08048360 000360 00026c 00  AX  0   0 16<br>  [15] .fini             PROGBITS        080485cc 0005cc 00001c 00  AX  0   0  4<br>  [16] .rodata           PROGBITS        080485e8 0005e8 000089 00   A  0   0  4<br>  [17] .eh_frame         PROGBITS        08048674 000674 000004 00   A  0   0  4<br>  [18] .ctors            PROGBITS        08049f0c 000f0c 000008 00  WA  0   0  4<br>  [19] .dtors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4<br>  [20] .jcr              PROGBITS        08049f1c 000f1c 000004 00  WA  0   0  4<br>  [21] .dynamic          DYNAMIC         08049f20 000f20 0000d0 08  WA  7   0  4<br>  [22] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4<br>  [23] .got.plt          PROGBITS        08049ff4 000ff4 00001c 04  WA  0   0  4<br>  [24] .data             PROGBITS        0804a010 001010 000018 00  WA  0   0  4<br>  [25] .bss              NOBITS          0804a028 001028 000010 00  WA  0   0  4<br>  [26] .comment          PROGBITS        00000000 001028 000048 01  MS  0   0  1<br>  [27] .shstrtab         STRTAB          00000000 001070 0000ee 00      0   0  1<br>  [28] .symtab           SYMTAB          00000000 001610 000480 10     29  47  4<br>  [29] .strtab           STRTAB          00000000 001a90 000251 00      0   0  1<br>Key to Flags:<br>  W (write), A (alloc), X (execute), M (merge), S (strings)<br>  I (info), L (link order), G (group), x (unknown)<br>  O (extra OS processing required) o (OS specific), p (processor specific)</pre><br>用readelf -l hello查看下段信息，注意这里还打印出了段与节的对应关系（Section to Segment mapping）：</p>
<p><pre>Elf file type is EXEC (Executable file)<br>Entry point 0x8048360<br>There are 8 program headers, starting at offset 52</pre></p>
<p>Program Headers:<br>  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align<br>  PHDR           0x000034 0x08048034 0x08048034 0x00100 0x00100 R E 0x4<br>  INTERP         0x000134 0x08048134 0x08048134 0x00013 0x00013 R   0x1<br>      [Requesting program interpreter: /lib/ld-linux.so.2]<br>  LOAD           0x000000 0x08048000 0x08048000 0x00678 0x00678 R E 0x1000<br>  LOAD           0x000f0c 0x08049f0c 0x08049f0c 0x0011c 0x0012c RW  0x1000<br>  DYNAMIC        0x000f20 0x08049f20 0x08049f20 0x000d0 0x000d0 RW  0x4<br>  NOTE           0x000148 0x08048148 0x08048148 0x00044 0x00044 R   0x4<br>  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4<br>  GNU_RELRO      0x000f0c 0x08049f0c 0x08049f0c 0x000f4 0x000f4 R   0x1</p>
<p> Section to Segment mapping:<br>  Segment Sections…<br>   00<br>   01     .interp<br>   02     .interp .note.ABI-tag .note.gnu.build-id .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame<br>   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss<br>   04     .dynamic<br>   05     .note.ABI-tag .note.gnu.build-id<br>   06<br>   07     .ctors .dtors .jcr .dynamic .got<br>结合前面程序运行结果，很容易可以发现如下事实：</p>
<p>main函数的地址0x8048414属于.text节，放在只读段中</p>
<p>常量字符串“abc”的地址（也就是str指针指向的地址）0x80485f0属于.rodata节，也放在只读段中</p>
<p>已初始化的两个全局变量（地址分别为0x804a018和0x804a01c）属于.data节，放在读写段中</p>
<p>未初始化的两个全局变量属于.bss节，放在读写段中</p>
<p>两个初始化的静态变量与初始化过的全局变量一样，属于.data节</p>
<p>可以猜到（代码中没写），未初始化的静态变量应该和未初始化的全局变量类似了</p>
<p>两个局部变量的地址0xbfeb3a78和0xbfeb3a74，看下上面程序运行时的存储器映像图就明白了，局部变量是放在栈中的，而且是从高地址向低地址增长，这里都得到了验证。</p>
<p>最后剩下p，它由malloc分配，所以应该放在运行时的堆中，可以看到它的位置在读写段的后面</p>
<p>好了，以后再也不怕类似的笔试题了= =。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>学C语言的第一个程序就是以下这个helloworld程序:</p>
<p>[c]</p>
<p>#include</p>
<p>int main()<br>{<br>    printf(&quot;hello, world!\n&quot;);<br>}<br>[/c]</p>
<p>它通过gcc -o hello hello.c编译，然后通过./hello就可以运行了，屏幕上打印出”hello, world\n”</p>
<p>不过它是如何被编译和链接的，又是如何在系统中运行的？第二次看《深入理解计算机系统》，终于明白了一点，所以做个总结。</p>
<h1 id="编译"><span style="color: #ff0000;">编译</span></h1><p>gcc -o hello hello.c这个命令其实gcc帮你干完了编译和链接两个工作。（编译其实还包括了汇编，可以把<em>.c-&gt;</em>.s理解为编译，.s-&gt;.o理解为汇编）</p>
<p>如果想只编译那么要用-c选项，gcc -c hello.c，这会生成一个hello.o文件，这是一个可重定位目标文件，有关可重定位目标文件，我在<a href="http://lsharemy.com/wordpress/index.php/csit/elf-file-format/">这篇文章</a>里做过总结。</p>
<p>这个文件由一个ELF头、一个节头部表、以及很多个节组成。]]>
    
    </summary>
    
      <category term="CSAPP" scheme="http://lsharemy.com/tags/CSAPP/"/>
    
      <category term="Notes" scheme="http://lsharemy.com/tags/Notes/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ELF文件格式探索]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/elf-file-format/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/elf-file-format/</id>
    <published>2012-09-15T07:51:42.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>这两天在看《深入理解计算机系统》</p>
<p>今天又不小心看到fyzhao的<a href="http://blog.csdn.net/fyzhao/article/details/5931999" target="_blank" rel="external">这篇文章</a>，于是打算研究一下</p>
<p>先拿以下代码开刀：</p>
<p>[c]<br>int accum = 0;</p>
<p>int sum(int x, int y)<br>{<br>    int t = x + y;<br>    accum += t;<br>    return t;<br>}<br>[/c]</p>
<p>用gcc -O1 -c code.c来编译，生成code.o，用xxd来查看二进制信息：</p>
<p><pre>0000000: <span style="color: #00ff00;">7f45 4c46 0101 0100 0000 0000 0000 0000</span>  .ELF…………<br>0000010: <span style="color: #ff00ff;">0100</span> <span style="color: #ff9900;">0300</span><span style="color: #3366ff;"> 0100 0000</span> <span style="color: #00ccff;">0000 0000</span> <span style="color: #993366;">0000 0000</span>  …………….<br>0000020: <span style="color: #ff99cc;">b800 0000</span> <span style="color: #cc99ff;">0000 0000</span> <span style="color: #ff0000;">3400</span> <span style="color: #ff99cc;">0000</span> <span style="color: #99ccff;">0000</span> <span style="color: #339966;">2800</span>  ……..4…..(.<br>0000030: <span style="color: #00ffff;">0a00</span> <span style="color: #993366;">0700</span> <span style="color: #3366ff;">5589 e58b 450c 0345 0801 0500</span>  ….U…E..E….<br>0000040: <span style="color: #3366ff;">0000 005d c3</span>00 0000 <span style="color: #993366;">0047 4343 3a20 2855</span>  …]…..GCC: (U<br>0000050: <span style="color: #993366;">6275 6e74 7520 342e 342e 332d 3475 6275</span>  buntu 4.4.3-4ubu<br>0000060: <span style="color: #993366;">6e74 7535 2e31 2920 342e 342e 3300</span> <span style="color: #ff0000;">002e</span>  ntu5.1) 4.4.3…<br>0000070: <span style="color: #ff0000;">7379 6d74 6162 002e 7374 7274 6162 002e</span>  symtab..strtab..<br>0000080: <span style="color: #ff0000;">7368 7374 7274 6162 002e 7265 6c2e 7465</span>  shstrtab..rel.te<br>0000090: <span style="color: #ff0000;">7874 002e 6461 7461 002e 6273 7300 2e63</span>  xt..data..bss..c<br>00000a0: <span style="color: #ff0000;">6f6d 6d65 6e74 002e 6e6f 7465 2e47 4e55</span>  omment..note.GNU<br>00000b0: <span style="color: #ff0000;">2d73 7461 636b 00</span>00 <span style="color: #ff00ff;">0000 0000 0000 0000</span>  -stack……….<br>00000c0: <span style="color: #ff00ff;">0000 0000 0000 0000 0000 0000 0000 0000</span>  …………….<br>00000d0: <span style="color: #ff00ff;">0000 0000 0000 0000 0000 0000 0000 0000</span>  …………….<br>00000e0: <span style="color: #ff0000;">1f00 0000 0100 0000 0600 0000 0000 0000</span>  …………….<br>00000f0: <span style="color: #ff0000;">3400 0000 1100 0000 0000 0000 0000 0000</span>  4……………<br>0000100: <span style="color: #ff0000;">0400 0000 0000 0000</span> <span style="color: #00ff00;">1b00 0000 0900 0000</span>  …………….<br>0000110: <span style="color: #00ff00;">0000 0000 0000 0000 ec02 0000 0800 0000</span>  …………….<br>0000120: <span style="color: #00ff00;">0800 0000 0100 0000 0400 0000 0800 0000</span>  …………….<br>0000130: <span style="color: #ff9900;">2500 0000 0100 0000 0300 0000 0000 0000</span>  %……………<br>0000140: <span style="color: #ff9900;">4800 0000 0000 0000 0000 0000 0000 0000</span>  H……………<br>0000150: <span style="color: #ff9900;">0400 0000 0000 0000</span> <span style="color: #00ffff;">2b00 0000 0800 0000</span>  ……..+…….<br>0000160: <span style="color: #00ffff;">0300 0000 0000 0000 4800 0000 0400 0000</span>  ……..H…….<br>0000170: <span style="color: #00ffff;">0000 0000 0000 0000 0400 0000 0000 0000</span>  …………….<br>0000180: <span style="color: #cc99ff;">3000 0000 0100 0000 3000 0000 0000 0000</span>  0…….0…….<br>0000190: <span style="color: #cc99ff;">4800 0000 2600 0000 0000 0000 0000 0000</span>  H…&amp;………..<br>00001a0: <span style="color: #cc99ff;">0100 0000 0100 0000</span> <span style="color: #ff99cc;">3900 0000 0100 0000</span>  ……..9…….<br>00001b0: <span style="color: #ff99cc;">0000 0000 0000 0000 6e00 0000 0000 0000</span>  ……..n…….<br>00001c0: <span style="color: #ff99cc;">0000 0000 0000 0000 0100 0000 0000 0000</span>  …………….<br>00001d0: <span style="color: #3366ff;">1100 0000 0300 0000 0000 0000 0000 0000</span>  …………….<br>00001e0: <span style="color: #3366ff;">6e00 0000 4900 0000 0000 0000 0000 0000</span>  n…I………..<br>00001f0: <span style="color: #3366ff;">0100 0000 0000 0000</span> <span style="color: #99ccff;">0100 0000 0200 0000</span>  …………….<br>0000200: <span style="color: #99ccff;">0000 0000 0000 0000 4802 0000 9000 0000</span>  ……..H…….<br>0000210: <span style="color: #99ccff;">0900 0000 0700 0000 0400 0000 1000 0000</span>  …………….<br>0000220: <span style="color: #33cccc;">0900 0000 0300 0000 0000 0000 0000 0000</span>  …………….<br>0000230: <span style="color: #33cccc;">d802 0000 1200 0000 0000 0000 0000 0000</span>  …………….<br>0000240: <span style="color: #33cccc;">0100 0000 0000 0000</span> <span style="color: #ff6600;">0000 0000 0000 0000</span>  …………….<br>0000250: <span style="color: #ff6600;">0000 0000 0000 0000 0100 0000 0000 0000</span>  …………….<br>0000260: <span style="color: #ff6600;">0000 0000 0400 f1ff 0000 0000 0000 0000</span>  …………….<br>0000270: <span style="color: #ff6600;">0000 0000 0300 0100 0000 0000 0000 0000</span>  …………….<br>0000280: <span style="color: #ff6600;">0000 0000 0300 0300 0000 0000 0000 0000</span>  …………….<br>0000290: <span style="color: #ff6600;">0000 0000 0300 0400 0000 0000 0000 0000</span>  …………….<br>00002a0: <span style="color: #ff6600;">0000 0000 0300 0600 0000 0000 0000 0000</span>  …………….<br>00002b0: <span style="color: #ff6600;">0000 0000 0300 0500 0800 0000 0000 0000</span>  …………….<br>00002c0: <span style="color: #ff6600;">1100 0000 1200 0100 0c00 0000 0000 0000</span>  …………….<br>00002d0: <span style="color: #ff6600;">0400 0000 1100 0400</span> <span style="color: #00ccff;">0063 6f64 652e 6300</span>  ………code.c.<br>00002e0: <span style="color: #00ccff;">7375 6d00 6163 6375 6d00</span> 0000 <span style="color: #00ff00;">0b00 0000</span>  sum.accum…….<br>00002f0: <span style="color: #00ff00;">0108 0000</span>                                ….</pre><br>然后对照文档来分析，忽忽</p>
<p>首先是ELF头：<a id="more"></a></p>
<p>[c]</p>
<p>#define EI_NIDENT 16<br>typedef struct {<br>unsigned char e_ident[EI_NIDENT];<br>Elf32_Half e_type;<br>Elf32_Half e_machine;<br>Elf32_Word e_version;<br>Elf32_Addr e_entry;<br>Elf32_Off e_phoff;<br>Elf32_Off e_shoff;<br>Elf32_Word e_flags;<br>Elf32_Half e_ehsize;<br>Elf32_Half e_phentsize;<br>Elf32_Half e_phnum;<br>Elf32_Half e_shentsize;<br>Elf32_Half e_shnum;<br>Elf32_Half e_shstrndx;<br>} Elf32_Ehdr;<br>[/c]</p>
<p>其中的e_ident[]数组中各个字节所代表的含义如下:</p>
<p>名字 索引 用途<br>EI_MAG0 0 文件标志<br>EI_MAG1 1 文件标志<br>EI_MAG2 2 文件标志<br>EI_MAG3 3 文件标志<br>EI_CLASS 4 文件类别<br>EI_DATA 5 编码格式<br>EI_VERSION 6 文件版本<br>EI_PAD 7 补齐字节开始位置<br>EI_NIDENT 16 e_ident[]数组的大小</p>
<p>前四个字节是“魔数”，分别为0x7f、’E’、’L’、’F’。</p>
<p>EI_CLASS字段的含义如下，这里是32位的：</p>
<p>名字 值 意义<br>ELFCLASSNONE 0 非法目标文件<br>ELFCLASS32 1 32 位目标文件<br>ELFCLASS64 2 64 位目标文件</p>
<p>EI_DATA字段的含义如下，这里为小端模式：<br>名字 值 意义<br>ELFDATANONE 0 非法编码格式<br>ELFDATA2LSB 1 LSB 编码(小头编码)<br>ELFDATA2MSB 2 MSB 编码(大头编码)</p>
<p>EI_VERSION字段表明ELF文件的版本号，当前为1</p>
<p>EI_PAD为9字节的填充，用于扩展。</p>
<p>e_type的含义如下，这里是1，表示可重定位文件：</p>
<p>名字 值 意义<br>ET_NONE 0 未知文件类型<br>ET_REL 1 可重定位文件<br>ET_EXEC 2 可执行文件<br>ET_DYN 3 动态链接库文件<br>ET_CORE 4 Core 文件<br>ET_LOPROC 0xff00 特定处理器文件扩展下边界<br>ET_HIPROC 0xffff 特定处理器文件扩展上边界</p>
<p>e_machine的含义如下，这里为3，Intel：</p>
<p>名字 值 意义<br>EM_NONE 0 未知体系结构<br>EM_M32 1 AT&amp;T WE 32100<br>16<br>ELF 格式解析<br>EM_SPARC 2 SPARC<br>EM_386 3 Intel Architecture<br>EM_68K 4 Motorola 68000<br>EM_88K 5 Motorola 88000<br>EM_860 7 Intel 80860<br>EM_MIPS 8 MIPS RS3000 Big-Endian<br>EM_MIPS_RS4-BE 10 MIPS RS4000 Big-Endian<br>RESERVED 11 ~ 16 保留未用</p>
<p>e_version表明ELF文件的版本号，当前为1（与前面的EI_VERSION一样吧）</p>
<p>e_entry表示程序的入口地址，这个不是可执行文件，所以是0</p>
<p>e_phoff指明程序头表(program header table)开始处在文件中的偏移量。如果没<br>有程序头表,该值应设为0。</p>
<p>e_shoff指明节头表(section header table)开始处在文件中的偏移量。如果没有节<br>头表,该值应设为0。这里为0xb8，十进制为184。</p>
<p>e_flags此字段含有处理器特定的标志位。标志的名字符合”EF_machine_flag”的格<br>式。对于 Intel 架构的处理器来说,它没有定义任何标志位,所以 e_flags 应该为<br>0。</p>
<p>e_ehsize表示ELF 文件头大小，共0x34个字节，即52字节</p>
<p>e_phentsize，程序头表中表项的大小。由于本文件中没有程序头表，所以为0。</p>
<p>e_phnum，程序头表中的项数。由于本文件中没有程序头表，所以为 0。</p>
<p>e_shentsize，节头表中表项的大小。这里为 0x28。即40字节。</p>
<p>e_shnum，节头表中的表项数。这里为 0x0a，即10项。</p>
<p>e_shstrndx，节头字符串表索引，此处为7。</p>
<p>到这里一共52字节，与e_ehsize的值一致，以上就是ELF头了</p>
<hr>
<p>接下去是节头表（Section Headers）</p>
<p>由ELF头中的信息可知节头表中有10项，每项40字节，偏移为0xb8。</p>
<p>上面分别用10个颜色标记出来了，从0xb8开始，到0x247。</p>
<p>每个节头的结构如下：</p>
<p>[c]<br>typedef struct {<br>Elf32_Word sh_name;<br>Elf32_Word sh_type;<br>Elf32_Word sh_flags;<br>Elf32_Addr sh_addr;<br>Elf32_Off sh_offset;<br>Elf32_Word sh_size;<br>Elf32_Word sh_link;<br>Elf32_Word sh_info;<br>Elf32_Word sh_addralign;<br>Elf32_Word sh_entsize;<br>} Elf32_Shdr;<br>[/c]</p>
<p>sh_name，本节的名字。整个名字的字符串并不存储在这里，它仅是一个索引号，指向“字符串表”节中的某个位置，那里存储了一个以’\0’结尾的字符串。</p>
<p>sh_type，本节的类型。下表给出了所有的节类型。</p>
<p>名字 值<br>SHT_NULL 0<br>SHT_PROGBITS 1<br>SHT_SYMTAB 2<br>SHT_STRTAB 3<br>SHT_RELA 4<br>SHT_HASH 5<br>SHT_DYNAMIC 6<br>SHT_NOTE 7<br>SHT_NOBITS 8<br>SHT_REL 9<br>SHT_SHLIB 10<br>SHT_DYNSYM 11<br>SHT_LOPROC 0x70000000<br>SHT_HIPROC 0x7fffffff<br>SHT_LOUSER 0x80000000<br>SHT_HIUSER 0xffffffff</p>
<p>具体含义这里不贴了，可以通过google关键字sh_type找到。</p>
<p>sh_flags，本节的一些属性，由一系列标志比特位组成，各个比特定义了节的不同属性，当某种属性被设置时，相应的标志位被设为1，反之则设为0。未定义的标志位被全部置0。<br>以下是这些标志位的列表及含义。</p>
<p>名字 值<br>SHF_WRITE 0x1<br>SHF_ALLOC 0x2<br>SHF_EXECINSTR 0x4<br>SHF_MASHPROC 0xf0000000</p>
<p>sh_addr，如果本节的内容需要映射到进程空间中去，此成员指定映射的起始地址；如果不需要映射,此值为0。</p>
<p>sh_offset指明了本节所在的位置，该值是节的第一个字节在文件中的位置，即相对于文件开头的偏移量。单位是字节。如果该节的类型为SHT_NOBITS的话，表明这一节的内容是空的，节并不占用实际的空间，这时sh_offset只代表一个逻辑上的位置概念，并不代表实际的内容。</p>
<p>sh_size，指明节的大小，单位是字节。如果该节的类型为SHT_NOBITS，此值仍然可能为非零，但没有实际的意义。</p>
<p>sh_link，此成员是一个索引值，指向节头表中本节所对应的位置。根据节的类型不同，本成员的意义也有所不同。</p>
<p>sh_info，此成员含有此节的附加信息，根据节的类型不同，本成员的意义也有所不同。</p>
<p>sh_addralign，此成员指明本节内容如何对齐字节，即该节的地址应该向多少个字节对齐。</p>
<p>sh_entsize，有一些节的内容是一张表，其中每一个表项的大小是固定的，比如符号表。对于这种表来说，本成员指定其每一个表项的大小。如果此值为0则表明本节内容不是这种表格。</p>
<hr>
<p>通过readelf命令查看以下code.o的节头表：</p>
<p><pre>Section Headers:<br>  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al<br>  [ 0]                   NULL            00000000 000000 000000 00      0   0  0<br>  [ 1] .text             PROGBITS        00000000 000034 000011 00  AX  0   0  4<br>  [ 2] .rel.text         REL             00000000 0002ec 000008 08      8   1  4<br>  [ 3] .data             PROGBITS        00000000 000048 000000 00  WA  0   0  4<br>  [ 4] .bss              NOBITS          00000000 000048 000004 00  WA  0   0  4<br>  [ 5] .comment          PROGBITS        00000000 000048 000026 01  MS  0   0  1<br>  [ 6] .note.GNU-stack   PROGBITS        00000000 00006e 000000 00      0   0  1<br>  [ 7] .shstrtab         STRTAB          00000000 00006e 000049 00      0   0  1<br>  [ 8] .symtab           SYMTAB          00000000 000248 000090 10      9   7  4<br>  [ 9] .strtab           STRTAB          00000000 0002d8 000012 00      0   0  1<br>Key to Flags:<br>  W (write), A (alloc), X (execute), M (merge), S (strings)<br>  I (info), L (link order), G (group), x (unknown)<br>  O (extra OS processing required) o (OS specific), p (processor specific)</pre><br>先看下节名字符串表项(.shstrtab)：</p>
<p><pre>1100 0000 0300 0000 0000 0000 0000 0000<br>6e00 0000 4900 0000 0000 0000 0000 0000<br>0100 0000 0000 0000</pre><br>sh_name为0x11</p>
<p>sh_type，值为0x03，即SHT_STRTAB，表明此表项指向一个字符串表。对于字符串表，我们只关心此表的起始地址和长度。</p>
<p>sh_offset,本节在文件中的偏移量。值是0x6e，这里是字符串表的起始位<br>置。</p>
<p>sh_size，本节的大小，即字符串表的长度，值为0x49。</p>
<p>根据这两个值，可以找到节名字符串节的位置在0x6e - 0xb7，可以看到里面存的都是节名字符串。而且偏移为0x11的字符串正是.shstrtab。</p>
<hr>
<p>同理，可以找到代码节(.text)的起始地址和长度分别为0x34和0x11。</p>
<p>段的具体内容为5589 e58b 450c 0345 0801 0500 0000 005d c3</p>
<p>可以通过objdump对code.o的代码段进行反编译：</p>
<p><pre>00000000 &lt;sum&gt;:<br>   0:    55                       push   %ebp<br>   1:    89 e5                    mov    %esp,%ebp<br>   3:    8b 45 0c                 mov    0xc(%ebp),%eax<br>   6:    03 45 08                 add    0x8(%ebp),%eax<br>   9:    01 05 00 00 00 00        add    %eax,0x0<br>   f:    5d                       pop    %ebp<br>  10:    c3                       ret</pre><br>可以发现，代码段的内容就是程序编译后的机器代码。</p>
<hr>
<p>再看以下符号表(.symtab)</p>
<p>sh_type 值为2，即SHT_SYMTAB，表明此表项指向一个符号表。</p>
<p>sh_offset，即符号表在文件中的偏移量，值为0x0248。</p>
<p>sh_size，符号表的大小，值为0x90。</p>
<p>sh_entsize，值为0x010。即符号表中每一个表项的大小为0x010。</p>
<p>目标文件中的“符号表(symbol table)”所包含的信息用于定位和重定位程序中的符号定义和引用。</p>
<p>这里直接用readelf命令来查看下符号表：</p>
<p><pre>Symbol table ‘.symtab’ contains 9 entries:<br>   Num:    Value  Size Type    Bind   Vis      Ndx Name<br>     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND<br>     1: 00000000     0 FILE    LOCAL  DEFAULT  ABS code.c<br>     2: 00000000     0 SECTION LOCAL  DEFAULT    1<br>     3: 00000000     0 SECTION LOCAL  DEFAULT    3<br>     4: 00000000     0 SECTION LOCAL  DEFAULT    4<br>     5: 00000000     0 SECTION LOCAL  DEFAULT    6<br>     6: 00000000     0 SECTION LOCAL  DEFAULT    5<br>     7: 00000000    17 FUNC    GLOBAL DEFAULT    1 sum<br>     8: 00000000     4 OBJECT  GLOBAL DEFAULT    4 accum</pre><br>其中第7项和第8项是程序中定义的全局变量和函数</p>
<p>Ndx列表示此符号是和哪个节相关的，或者说定义在哪个节中，sum在代码节中，序号为1，accum在bss中，序号为4（程序中已经将accum初始化为0了，为什么还在bss中呢？后来改成accum=1试了以下，序号变成了3，说明就放到了data节中。也就是说初始化为0，系统就当成是没有初始化的？）</p>
<p>Value列给出了大小，sum函数的大小为17字节，accum变量为4字节</p>
<hr>
<p>还有几个不为空的节，也看以下吧</p>
<p>先是.rel.text，这个节定义了需要重定位的函数或全局变量，用readelf查看一下：</p>
<p><pre>Relocation section ‘.rel.text’ at offset 0x2ec contains 1 entries:<br> Offset     Info    Type            Sym.Value  Sym. Name<br>0000000b  00000801 R_386_32          00000000   accum</pre><br>看到只有一个条目，表示在代码段偏移为b的一个变量accum需要重定位，目前它的地址被设置成了0x00000000（也可以在上面反汇编代码中看到）。因为链接的时候才能确定accum的具体地址，到时需要修改这个地址为accum的真实地址。</p>
<hr>
<p>comment节应该就是个注释，不管了</p>
<hr>
<p>还有最后一个.strtab节，是一个字符串表，里面存了.symtab中的符号。这个例子中就是sum和accum</p>
<hr>
<p>好吧，终于分析完了，这只是分析了一种类型的目标文件（可重定位文件），其他还包括共享目标文件和可执行文件。</p>
<p>不过借助readelf工具，应该就很容易分析啦。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这两天在看《深入理解计算机系统》</p>
<p>今天又不小心看到fyzhao的<a href="http://blog.csdn.net/fyzhao/article/details/5931999">这篇文章</a>，于是打算研究一下</p>
<p>先拿以下代码开刀：</p>
<p>[c]<br>int accum = 0;</p>
<p>int sum(int x, int y)<br>{<br>    int t = x + y;<br>    accum += t;<br>    return t;<br>}<br>[/c]</p>
<p>用gcc -O1 -c code.c来编译，生成code.o，用xxd来查看二进制信息：</p>
<p><pre>0000000: <span style="color: #00ff00;">7f45 4c46 0101 0100 0000 0000 0000 0000</span>  .ELF…………<br>0000010: <span style="color: #ff00ff;">0100</span> <span style="color: #ff9900;">0300</span><span style="color: #3366ff;"> 0100 0000</span> <span style="color: #00ccff;">0000 0000</span> <span style="color: #993366;">0000 0000</span>  …………….<br>0000020: <span style="color: #ff99cc;">b800 0000</span> <span style="color: #cc99ff;">0000 0000</span> <span style="color: #ff0000;">3400</span> <span style="color: #ff99cc;">0000</span> <span style="color: #99ccff;">0000</span> <span style="color: #339966;">2800</span>  ……..4…..(.<br>0000030: <span style="color: #00ffff;">0a00</span> <span style="color: #993366;">0700</span> <span style="color: #3366ff;">5589 e58b 450c 0345 0801 0500</span>  ….U…E..E….<br>0000040: <span style="color: #3366ff;">0000 005d c3</span>00 0000 <span style="color: #993366;">0047 4343 3a20 2855</span>  …]…..GCC: (U<br>0000050: <span style="color: #993366;">6275 6e74 7520 342e 342e 332d 3475 6275</span>  buntu 4.4.3-4ubu<br>0000060: <span style="color: #993366;">6e74 7535 2e31 2920 342e 342e 3300</span> <span style="color: #ff0000;">002e</span>  ntu5.1) 4.4.3…<br>0000070: <span style="color: #ff0000;">7379 6d74 6162 002e 7374 7274 6162 002e</span>  symtab..strtab..<br>0000080: <span style="color: #ff0000;">7368 7374 7274 6162 002e 7265 6c2e 7465</span>  shstrtab..rel.te<br>0000090: <span style="color: #ff0000;">7874 002e 6461 7461 002e 6273 7300 2e63</span>  xt..data..bss..c<br>00000a0: <span style="color: #ff0000;">6f6d 6d65 6e74 002e 6e6f 7465 2e47 4e55</span>  omment..note.GNU<br>00000b0: <span style="color: #ff0000;">2d73 7461 636b 00</span>00 <span style="color: #ff00ff;">0000 0000 0000 0000</span>  -stack……….<br>00000c0: <span style="color: #ff00ff;">0000 0000 0000 0000 0000 0000 0000 0000</span>  …………….<br>00000d0: <span style="color: #ff00ff;">0000 0000 0000 0000 0000 0000 0000 0000</span>  …………….<br>00000e0: <span style="color: #ff0000;">1f00 0000 0100 0000 0600 0000 0000 0000</span>  …………….<br>00000f0: <span style="color: #ff0000;">3400 0000 1100 0000 0000 0000 0000 0000</span>  4……………<br>0000100: <span style="color: #ff0000;">0400 0000 0000 0000</span> <span style="color: #00ff00;">1b00 0000 0900 0000</span>  …………….<br>0000110: <span style="color: #00ff00;">0000 0000 0000 0000 ec02 0000 0800 0000</span>  …………….<br>0000120: <span style="color: #00ff00;">0800 0000 0100 0000 0400 0000 0800 0000</span>  …………….<br>0000130: <span style="color: #ff9900;">2500 0000 0100 0000 0300 0000 0000 0000</span>  %……………<br>0000140: <span style="color: #ff9900;">4800 0000 0000 0000 0000 0000 0000 0000</span>  H……………<br>0000150: <span style="color: #ff9900;">0400 0000 0000 0000</span> <span style="color: #00ffff;">2b00 0000 0800 0000</span>  ……..+…….<br>0000160: <span style="color: #00ffff;">0300 0000 0000 0000 4800 0000 0400 0000</span>  ……..H…….<br>0000170: <span style="color: #00ffff;">0000 0000 0000 0000 0400 0000 0000 0000</span>  …………….<br>0000180: <span style="color: #cc99ff;">3000 0000 0100 0000 3000 0000 0000 0000</span>  0…….0…….<br>0000190: <span style="color: #cc99ff;">4800 0000 2600 0000 0000 0000 0000 0000</span>  H…&amp;………..<br>00001a0: <span style="color: #cc99ff;">0100 0000 0100 0000</span> <span style="color: #ff99cc;">3900 0000 0100 0000</span>  ……..9…….<br>00001b0: <span style="color: #ff99cc;">0000 0000 0000 0000 6e00 0000 0000 0000</span>  ……..n…….<br>00001c0: <span style="color: #ff99cc;">0000 0000 0000 0000 0100 0000 0000 0000</span>  …………….<br>00001d0: <span style="color: #3366ff;">1100 0000 0300 0000 0000 0000 0000 0000</span>  …………….<br>00001e0: <span style="color: #3366ff;">6e00 0000 4900 0000 0000 0000 0000 0000</span>  n…I………..<br>00001f0: <span style="color: #3366ff;">0100 0000 0000 0000</span> <span style="color: #99ccff;">0100 0000 0200 0000</span>  …………….<br>0000200: <span style="color: #99ccff;">0000 0000 0000 0000 4802 0000 9000 0000</span>  ……..H…….<br>0000210: <span style="color: #99ccff;">0900 0000 0700 0000 0400 0000 1000 0000</span>  …………….<br>0000220: <span style="color: #33cccc;">0900 0000 0300 0000 0000 0000 0000 0000</span>  …………….<br>0000230: <span style="color: #33cccc;">d802 0000 1200 0000 0000 0000 0000 0000</span>  …………….<br>0000240: <span style="color: #33cccc;">0100 0000 0000 0000</span> <span style="color: #ff6600;">0000 0000 0000 0000</span>  …………….<br>0000250: <span style="color: #ff6600;">0000 0000 0000 0000 0100 0000 0000 0000</span>  …………….<br>0000260: <span style="color: #ff6600;">0000 0000 0400 f1ff 0000 0000 0000 0000</span>  …………….<br>0000270: <span style="color: #ff6600;">0000 0000 0300 0100 0000 0000 0000 0000</span>  …………….<br>0000280: <span style="color: #ff6600;">0000 0000 0300 0300 0000 0000 0000 0000</span>  …………….<br>0000290: <span style="color: #ff6600;">0000 0000 0300 0400 0000 0000 0000 0000</span>  …………….<br>00002a0: <span style="color: #ff6600;">0000 0000 0300 0600 0000 0000 0000 0000</span>  …………….<br>00002b0: <span style="color: #ff6600;">0000 0000 0300 0500 0800 0000 0000 0000</span>  …………….<br>00002c0: <span style="color: #ff6600;">1100 0000 1200 0100 0c00 0000 0000 0000</span>  …………….<br>00002d0: <span style="color: #ff6600;">0400 0000 1100 0400</span> <span style="color: #00ccff;">0063 6f64 652e 6300</span>  ………code.c.<br>00002e0: <span style="color: #00ccff;">7375 6d00 6163 6375 6d00</span> 0000 <span style="color: #00ff00;">0b00 0000</span>  sum.accum…….<br>00002f0: <span style="color: #00ff00;">0108 0000</span>                                ….</pre><br>然后对照文档来分析，忽忽</p>
<p>首先是ELF头：]]>
    
    </summary>
    
      <category term="ELF" scheme="http://lsharemy.com/tags/ELF/"/>
    
      <category term="Linux" scheme="http://lsharemy.com/tags/Linux/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[USACO - TEXT Computational Geometry]]></title>
    <link href="http://lsharemy.com/wordpress/index.php/csit/usaco-text-computational-geometry/"/>
    <id>http://lsharemy.com/wordpress/index.php/csit/usaco-text-computational-geometry/</id>
    <published>2012-09-10T04:04:10.000Z</published>
    <updated>2015-08-15T02:15:24.000Z</updated>
    <content type="html"><![CDATA[<p>终于知道计算几何是什么了</p>
<p>首先是计算机几何的三个“工具”：叉积、点积、反正切</p>
<p>1.叉积<em>u x v</em></p>
<p><em>u x v的结果等于以下行列式的结果：</em></p>
<p>|  i    j    k  |<br>| ux uy uz |<br>| vx vy vz |</p>
<p>也就是等于(<em>u</em><sub>y</sub><em>v</em><sub>z</sub>-<em>v</em><sub>y</sub><em>u</em><sub> z</sub>)<strong>i</strong> + (<em>u</em><sub>z</sub><em>v</em><sub>x</sub>-<em>u</em><sub> x</sub><em>v</em><sub>z</sub>)<strong>j</strong> + (<em>u</em><sub>x</sub><em>v</em><sub> y</sub>-<em>u</em><sub>y</sub><em>v</em><sub>x</sub>)<strong>k</strong></p>
<p><img src="http://ace.delos.com/usaco/TEXT/geom6.gif" alt=""><a id="more"></a></p>
<p>叉积的三个性质：</p>
<p>（1）两个向量的叉积与这两个向量都垂直</p>
<p>（2）两个向量的叉积的长度=|u|<em>|v|</em>sin（夹角）</p>
<p>（3）两个向量的叉积的方向符合右手螺旋法则（手指从u到v，大姆子指的方向）</p>
<p><img src="http://ace.delos.com/usaco/TEXT/geom7.gif" alt=""></p>
<p>2.点积u · v</p>
<p><em>u和v的点积等于u</em><sub><em>x</em></sub><em>v</em><sub><em>x</em></sub> + <em>u</em> <sub>y</sub><em>v</em><sub>y</sub> + <em>u</em><sub>z</sub><em>v</em> <sub>z</sub></p>
<p>也等于|u|<em>|v|</em>cos（夹角）</p>
<p>如果点积为正，夹角是锐角；点积为负，夹角是钝角；点积为0，夹角为90度。</p>
<p>3.反正切Arctangent</p>
<p>C中的两个函数，一个是<em>atan，它返回-pi/2到pi/2之间的一个数</em></p>
<p>还有一个是<em>atan2，返回-pi到pi之间的一个数，可以确定象限，所以这个函数一般用的比较多</em></p>
<hr>
<p>注意：</p>
<p>1.几何问题往往有很多特例！要注意</p>
<p>2.浮点数的判等！要注意</p>
<hr>
<p>几何算法：</p>
<p>1.计算三角形面积</p>
<p>知道三个点的坐标：算出两个向量，三角行的面积等于向量叉积长度的一半</p>
<p>直到三条边的长度：令<em>s = (a+b+c)/2，则面积等于<em>sqrt(s<em> (s-a)</em>(s-b)*(s-c))</em></em></p>
<p><img src="http://ace.delos.com/usaco/TEXT/geom1.gif" alt=""></p>
<p>2.判断两条线段是否平行</p>
<p>在两条线上分别找出一个向量，看这两个向量是否平行，只要看它们的叉积是不是（几乎）等于0</p>
<p>3.多边形的面积</p>
<p>多边形的顶点为别为：(<em>x</em> <sub>1</sub>, <em>y</em> <sub>1</sub>), …, (<em>x</em> <sub>n</sub>, <em>y</em> <sub>n</sub>)，那么它的面积为：</p>
<table>
<thead>
<tr>
<th>1</th>
<th>x1 x2 … xn</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>y1 y2 … yn</td>
<td></td>
</tr>
</tbody>
</table>
<p>行列式的值等于<em>x</em><sub>1</sub> <em>y</em><sub>2 </sub>+ <em>x</em><sub>2</sub><em>y</em><sub>3</sub>+ … + <em>x</em><sub><em>n</em></sub> <em>y</em><sub>1</sub> - <em>y</em><sub>1</sub> <em>x</em><sub>2</sub> - <em>y</em><sub>2</sub><em>x</em><sub>3</sub> - … - <em>y</em><sub>n</sub> <em>x</em><sub>1</sub></p>
<p>4.点到直线的距离</p>
<p><em>d</em>(P,AB) = |(P - A) x (B - A)| / | B - A|，可由上面求三角形的面积转换而来</p>
<p>点P到由A、B、C构成的平面的距离：令<em>n</em> = (B - A) x (C - A)，则<em>d</em>(P,ABC) = (P-A) · n / |n|，n是垂直平面的一个向量，所以求出P到n的投影长度即可。</p>
<p>5.点是否在直线上</p>
<p>看该点到该直线的距离是否是0即可，见4</p>
<p>6.点是否在一条直线的同一边（二维）</p>
<p>查看C和D是否在AB直线的同一边，分别计算<em>(B - A) x (C - A)</em> and <em>(B - A) x (D - A)</em>的z分量的符号，如果两者的符号相同，则C和D在AB的同一边</p>
<p>7.点是否在一条线段上</p>
<p>要看C是否在线段AB上，只要看AB的长度是不是AC和CB的长度之和</p>
<p>8.点是否在三角形内</p>
<p>先找到三角形内的一个点B（比如三角形3个点取平均值），然后查看A和B是否都在三角行三条边的同一边。</p>
<p><img src="http://ace.delos.com/usaco/TEXT/geom3.gif" alt=""></p>
<p>9.点是否在凸多边形内</p>
<p>类似于8</p>
<p><img src="http://ace.delos.com/usaco/TEXT/geom4.gif" alt=""></p>
<p>10.4个点是否共面</p>
<p>选择其中3个点A、B、C，对于剩下的点D，如果满足(B - A) x (C - A)) · (D - A) = 0，则4点共面</p>
<p>11.2条直线相交</p>
<p>2维，不平行，则相交</p>
<p>3维，不平行且共面，则相交</p>
<p>12.2条线段相交</p>
<p>2维，当A、B分别在C、D的两边，同时C、D分别在AB的两边，则两直线相交</p>
<p><img src="http://ace.delos.com/usaco/TEXT/geom5.gif" alt=""></p>
<p>3维，如果以下方程组</p>
<p>A<sub><em>x</em></sub> + (B<sub><em>x</em></sub> - A<sub><em>x</em></sub>) i = C<sub><em>x</em></sub> + (D<sub><em>x</em></sub> - C<sub><em>x</em></sub>) j<br>A<sub><em>y</em></sub> + (B<sub><em>y</em></sub> - A<sub><em>y</em></sub>) i = C<sub><em>y</em></sub> + (D<sub><em>y</em></sub> - C<sub><em>y</em></sub>) j<br>A<sub><em>z</em></sub> + (B<sub><em>z</em></sub> - A<sub><em>z</em></sub>) i = C<sub><em>z</em></sub> + (D<sub><em>z</em></sub> - C<sub><em>z</em></sub>) j</p>
<p>存在一组解(<em>i</em>, <em>j</em>)，其中0 &lt;= <em>i</em> &lt;= 1且0 &lt;= <em>j</em> &lt;= 1。则AB和CD相交于 (A<sub><em>x</em></sub> + (B<sub><em>x</em></sub> - A<sub><em>x</em></sub>)i, A<sub><em>y</em></sub> + (B<sub><em>y</em></sub> - A<sub><em>y</em></sub>)i, A<sub><em>z</em></sub> + (B<sub><em>z</em></sub> - A<sub><em>z</em></sub>) i。</p>
<p>13.两条线段的交点</p>
<p>2维，解以下方程组</p>
<p>A<sub><em>x</em></sub> + (B<sub><em>x</em></sub> - A<sub><em>x</em></sub>)i = C<sub><em>x</em></sub> + (D<sub><em>x</em></sub> - C<sub><em>x</em></sub>) j<br>A<sub><em>y</em></sub> + (B<sub><em>y</em></sub> - A<sub><em>y</em></sub>)i = C<sub><em>y</em></sub> + (D<sub><em>y</em></sub> - C<sub><em>y</em></sub>) j</p>
<p>则交点为：(A<sub><em>x</em></sub> + (B<sub><em>x</em></sub> - A<sub><em>x</em></sub>) i, A<sub><em>y</em></sub> + (B<sub><em>y</em></sub> - A<sub><em>y</em></sub>) i)</p>
<p>3维，见12</p>
<p>14.多边形的凸性</p>
<p>按顺时针的方向沿着多边形走，对任意连续的三个点(A, B, C)，计算(B - A) x (C - A)的z分量，如果符号为都为正，这是凸多边形</p>
<p>15.点是否在一个非凸多边形中</p>
<p>从该点出发，向任意方向做一条射线，如果该射线经过了多变行的顶点或与多边形的某边重合，则重新作一条射线。如果该射线与多边形相交的边数为奇数，则在多边形内。</p>
<p><img src="http://ace.delos.com/usaco/TEXT/geom8.gif" alt=""></p>
<hr>
<p>几何方法：（没太理解透）</p>
<p>1.蒙特卡罗方法(<a href="http://zh.wikipedia.org/zh/%E8%92%99%E5%9C%B0%E5%8D%A1%E7%BE%85%E6%96%B9%E6%B3%95" target="_blank" rel="external">http://zh.wikipedia.org/zh/%E8%92%99%E5%9C%B0%E5%8D%A1%E7%BE%85%E6%96%B9%E6%B3%95</a>)</p>
<p>2.分区法</p>
<p><img src="http://ace.delos.com/usaco/TEXT/geom9.gif" alt=""></p>
<hr>
]]></content>
    <summary type="html">
    <![CDATA[<p>终于知道计算几何是什么了</p>
<p>首先是计算机几何的三个“工具”：叉积、点积、反正切</p>
<p>1.叉积<em>u x v</em></p>
<p><em>u x v的结果等于以下行列式的结果：</em></p>
<p>|  i    j    k  |<br>| ux uy uz |<br>| vx vy vz |</p>
<p>也就是等于(<em>u</em><sub>y</sub><em>v</em><sub>z</sub>-<em>v</em><sub>y</sub><em>u</em><sub> z</sub>)<strong>i</strong> + (<em>u</em><sub>z</sub><em>v</em><sub>x</sub>-<em>u</em><sub> x</sub><em>v</em><sub>z</sub>)<strong>j</strong> + (<em>u</em><sub>x</sub><em>v</em><sub> y</sub>-<em>u</em><sub>y</sub><em>v</em><sub>x</sub>)<strong>k</strong></p>
<p><img src="http://ace.delos.com/usaco/TEXT/geom6.gif" alt="">]]>
    
    </summary>
    
      <category term="USACO" scheme="http://lsharemy.com/tags/USACO/"/>
    
      <category term="wordpress" scheme="http://lsharemy.com/categories/wordpress/"/>
    
      <category term="index.php" scheme="http://lsharemy.com/categories/wordpress/index.php/"/>
    
      <category term="csit" scheme="http://lsharemy.com/categories/wordpress/index.php/csit/"/>
    
  </entry>
  
</feed>